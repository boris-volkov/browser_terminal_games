<!doctype html><html lang="en"><head>  <meta charset="utf-8">  <title>Ñ¬</title><link href="../../style.css" rel="stylesheet"/></head><body><div class="bookmark">./exe/speed_typer/c_code.txt</div><pre class=notes>
#include &ltstdio.h&gt

/**
 ** @file
 **
 ** This plays with gcc features to define a weird macro that emulates
 ** anonymous functions that can be used as closures. Don't use that
 ** seriously, this is only meant to prove that this is syntactically
 ** not a big deal, and that the ideas necessary for it can be found
 ** in modern compilers.
 **
 **/

/**
 ** @def ANONYMOUS(RET)
 ** @brief Use this to define an anonymous function with return type @a RET.
 **
 ** The @c ... argument list is the parameter list of the
 ** function. This the expects the code of the function in &ltcode&gt({
 ** })&lt/code&gt parenthesis. A simple example would be
 **
 ** @code
 ** // Function header
 ** ANONYMOUS(int) (double a, unsigned b)
 ** // Function body
 ** ({
 **    return printf("we found %g for %u, average %g\n", a, b, a/b);
 ** })
 ** // Function arguments
 ** (x, 23);
 ** @endcode
 **
 ** Of course you would usually put such things inside a macro. See
 ** MAX() for a more complicated example.
 **/
#ifdef __clang__
# define ANONYMOUS(RET) (^ RET ANON_PART2
# define ANON_PART2(...) (__VA_ARGS__) ANON_PART3
# define ANON_PART3(...) __VA_ARGS__)
#else
# define ANONYMOUS(RET) ({ RET __anon_func ANON_PART2
# define ANON_PART2(...) (__VA_ARGS__) ANON_PART3
# define ANON_PART3(...) __VA_ARGS__ __anon_func; })
#endif

#define MAXU(A, B)                              \
ANONYMOUS(uintmax_t) (uintmax_t a, uintmax_t b) \
({                                              \
    if (a &lt b) return b;                        \
    else return a;                              \
})                                              \
((A), (B))

#define MAX(A, B)                               \
/* function header */                           \
  /* return type */                             \
ANONYMOUS(__typeof__(1 ? (A) : (B)))            \
 /*and then argument list */                    \
(__typeof__(A) a, __typeof__(B) b)              \
/* function body */                             \
({                                              \
  if (a &lt b) return b;                          \
  else return a;                                \
 })                                             \
/* function call */                             \
((A), (B))

/**
 ** Test to see if that even works when such functions are nested.
 **/

typedef void df(unsigned);

df* Df[5] = { 0 };

void g(unsigned level, unsigned depth) {
  Df[depth%5] =
    ANONYMOUS(void) (register unsigned a)
    ({
      printf("from level %u, depth %u found in position %u\n",
             level, depth,
             MAX(2*a, depth)
             );
      return;
    });
  if (level)
    g(level-1, depth+1);
  else
    for (unsigned i = 0; i &lt 5; ++i)
      if (Df[i]) Df[i](i);
}


int main(int argc, char* argv[]) {
  g(argc, 0);
}
#include &ltstdio.h&gt

#ifdef USE_STRUCT
  typedef struct two two;
  struct two { double e1; double e2; };
# define FRST(X) ((X).e1)
# define SEC(X) ((X).e2)
#else
  typedef double two[2];
# define FRST(X) ((X)[0])
# define SEC(X) ((X)[1])
#endif

void func0(void) {
  for (two sp = { 1, 1, };
       FRST(sp) + SEC(sp) &lt 10;
       FRST(sp) += SEC(sp)) {
    printf("two values %g %g\n", FRST(sp), SEC(sp));
    SEC(sp) += (FRST(sp) + SEC(sp))/2;
  }
}

void func1(void) {
  for (register two sp = { 1, 1, };
       FRST(sp) + SEC(sp) &lt 10;
       FRST(sp) += SEC(sp)) {
    printf("two values %g %g\n", FRST(sp), SEC(sp));
    SEC(sp) += (FRST(sp) + SEC(sp))/2;
  }
}
#include "life.h"
#include &ltstdlib.h&gt
#include &ltstdio.h&gt
#include &ltstdbool.h&gt
#include &ltunistd.h&gt
#include &ltstdatomic.h&gt
#include &ltlimits.h&gt
#include "termin.h"

// The keys that are used for cursor movement
// Other keys that are used are:
// b, B, space for birth9
// -, + to slow down and accelerate
// q, Q to quit
#define GO_UP 'k'
#define GO_DOWN 'l'
#define GO_RIGHT ';'
#define GO_LEFT 'j'
#define GO_HOME 'h'

// We translate escape sequences that we may receive to these standard
// characters for further processing.

#define ESCAPE '\e'

char const*const termin_trans[UCHAR_MAX+1] = {
  [GO_UP] = ESC_UP,
  [GO_DOWN] = ESC_DOWN,
  [GO_RIGHT] = ESC_FRWD,
  [GO_LEFT] = ESC_BKWD,
  [GO_HOME] = ESC_HOME,
};

static
int update_thread(void* Lv) {
  life*restrict L = Lv;
  size_t changed = 1;
  size_t birth9 = 0;
  while (!L-&gtfinished && changed) {
    // Blocks until there is work
    mtx_lock(&L-&gtmtx);
    while (!L-&gtfinished && (L-&gtaccounted &lt L-&gtiteration))
      life_wait(&L-&gtupda, &L-&gtmtx);

    // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    if (birth9 != L-&gtbirth9) life_torus(L);
    life_count(L);
    changed = life_update(L);
    life_torus(L);
    birth9 = L-&gtbirth9;
    L-&gtiteration++;
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cnd_signal(&L-&gtacco);
    cnd_signal(&L-&gtdraw);
    mtx_unlock(&L-&gtmtx);

    life_sleep(1.0/L-&gtframes);
  }
  return 0;
}

static
int draw_thread(void* Lv) {
  life*restrict L = Lv;
  size_t x0 = 0;
  size_t x1 = 0;
  fputs(ESC_CLEAR ESC_CLRSCR, stdout);
  while (!L-&gtfinished) {
    // Blocks until there is work
    mtx_lock(&L-&gtmtx);
    while (!L-&gtfinished
           && (L-&gtiteration &lt= L-&gtdrawn)
           && (x0 == L-&gtx0)
           && (x1 == L-&gtx1)) {
      life_wait(&L-&gtdraw, &L-&gtmtx);
    }
    // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    if (L-&gtn0 &lt= 30) life_draw(L);
    else life_draw4(L);
    L-&gtdrawn++;
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    mtx_unlock(&L-&gtmtx);

    x0 = L-&gtx0;
    x1 = L-&gtx1;
    // No need to draw too quickly
    life_sleep(1.0/40);
  }
  return 0;
}

// This number of consecutive states that are already known (that is,
// hashed in) decides that this sequence of states is cyclic
enum { repetition = 10, };

static
int account_thread(void* Lv) {
  life*restrict L = Lv;
  while (!L-&gtfinished) {
    // Blocks until there is work
    mtx_lock(&L-&gtmtx);
    while (!L-&gtfinished && (L-&gtaccounted == L-&gtiteration))
      life_wait(&L-&gtacco, &L-&gtmtx);

    // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    life_account(L);
    if ((L-&gtlast + repetition) &lt L-&gtaccounted) {
      L-&gtfinished = true;
    }
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cnd_signal(&L-&gtupda);
    mtx_unlock(&L-&gtmtx);
  }
  return 0;
}

static
int input_thread(void* Lv) {
  termin_unbuffered();
  life*restrict L = Lv;
  enum { len = 32, };
  char command[len];
  do {
    int c = getchar();
    command[0] = c;
    switch(c) {
    case GO_LEFT : life_advance(L,  0, -1); break;
    case GO_RIGHT: life_advance(L,  0, +1); break;
    case GO_UP   : life_advance(L, -1,  0); break;
    case GO_DOWN : life_advance(L, +1,  0); break;
    case GO_HOME : L-&gtx0 = 1; L-&gtx1 = 1;    break;
    case ESCAPE  :
      ungetc(termin_translate(termin_read_esc(len, command)), stdin);
      continue;
    case '+':      if (L-&gtframes &lt 128) L-&gtframes++; continue;
    case '-':      if (L-&gtframes &gt 1)   L-&gtframes--; continue;
    case ' ':
    case 'b':
    case 'B':
      mtx_lock(&L-&gtmtx);
      // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
      life_birth9(L); /*@\label{lab:birth9}*/
      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      cnd_signal(&L-&gtdraw);
      mtx_unlock(&L-&gtmtx);
      continue;
    case 'q':
    case 'Q':
    case EOF:      goto FINISH;
    }
    cnd_signal(&L-&gtdraw);  /*@\label{lab:signal}*/
  } while (!(L-&gtfinished || feof(stdin)));
 FINISH:
  L-&gtfinished = true;
  return 0;
}

enum { n = 60, m = 160 };

bool M[n][m] = {
 { 0 },
 { 0 },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0 },
 { 0 },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0 },
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, },
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0 },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0 },
 { 0 },
 { 0 },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0 },
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0 },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0 },
 { 0 },
};

int main(int argc, char* argv[argc+1]) {
  /* Uses command-line arguments for the size of the board */
  size_t n0 = 30;
  size_t n1 = 80;
  if (argc &gt 1) n0 = strtoull(argv[1], 0, 0);
  if (argc &gt 2) n1 = strtoull(argv[2], 0, 0);
  /* Create an object that holds the game's data. */
  life L = LIFE_INITIALIZER;
  life_init(&L, n0, n1, M);
  /* Creates four threads that all operate on that same object
     and collects their IDs in "thrd" */
  thrd_t thrd[4];
  thrd_create(&thrd[0], update_thread,  &L);
  thrd_create(&thrd[1], draw_thread,    &L);
  thrd_create(&thrd[2], input_thread,   &L);
  thrd_create(&thrd[3], account_thread, &L);
  /* Waits for the update thread to terminate */
  thrd_join(thrd[0], 0);
  /* Tells everybody that the game is over */
  L.finished = true;
  ungetc('q', stdin);
  /* Waits for the other threads */
  thrd_join(thrd[1], 0);
  thrd_join(thrd[2], 0);
  thrd_join(thrd[3], 0);
  /* Puts the board in a nice final picture */
  L.iteration = L.last;
  life_draw(&L);
  life_destroy(&L);
}
#include "life.h"
#include &ltstdlib.h&gt
#include &ltstdio.h&gt
#include &ltstdbool.h&gt
#include &ltunistd.h&gt
#include &ltstdatomic.h&gt
#include &ltlimits.h&gt
#include "termin.h"

// The keys that are used for cursor movement.
// Other keys that are use are
// b, B, space for birth9
// -, + to slow down and accelerate
// q, Q to quit
#define GO_UP 'k'
#define GO_DOWN 'l'
#define GO_RIGHT ';'
#define GO_LEFT 'j'
#define GO_HOME 'h'

// We translate escape sequences that we may receive to these standard
// characters for further processing.

#define ESCAPE '\e'

char const*const termin_trans[UCHAR_MAX+1] = {
  [GO_UP] = ESC_UP,
  [GO_DOWN] = ESC_DOWN,
  [GO_RIGHT] = ESC_FRWD,
  [GO_LEFT] = ESC_BKWD,
  [GO_HOME] = ESC_HOME,
};

static int account_thread(void*);

static
int update_thread(void* Lv) {
  /* Nobody should ever wait for this thread. */
  thrd_detach(thrd_current());
  /* Delegates part of our job to an auxiliary thread */
  thrd_create(&(thrd_t){0}, account_thread, Lv);
  life*restrict L = Lv;
  size_t changed = 1;
  size_t birth9 = 0;
  while (!L-&gtfinished && changed) {
    // block until there is work
    mtx_lock(&L-&gtmtx);
    while (!L-&gtfinished && (L-&gtaccounted &lt L-&gtiteration))
      life_wait(&L-&gtupda, &L-&gtmtx);

    // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    if (birth9 != L-&gtbirth9) life_torus(L);
    life_count(L);
    changed = life_update(L);
    life_torus(L);
    birth9 = L-&gtbirth9;
    L-&gtiteration++;
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cnd_signal(&L-&gtacco);
    cnd_signal(&L-&gtdraw);
    mtx_unlock(&L-&gtmtx);

    life_sleep(1.0/L-&gtframes);
  }
  /* Tells everybody that the game is over */
  L-&gtfinished = true;
  ungetc('q', stdin);
  return 0;
}

static
int draw_thread(void* Lv) {
  /* Nobody should ever wait for this thread. */
  thrd_detach(thrd_current());
  life*restrict L = Lv;
  size_t x0 = 0;
  size_t x1 = 0;
  fputs(ESC_CLEAR ESC_CLRSCR, stdout);
  while (!L-&gtfinished) {
    // Blocks until there is work
    mtx_lock(&L-&gtmtx);
    while (!L-&gtfinished
           && (L-&gtiteration &lt= L-&gtdrawn)
           && (x0 == L-&gtx0)
           && (x1 == L-&gtx1))
      life_wait(&L-&gtdraw, &L-&gtmtx);

    // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    if (L-&gtn0 &lt= 30) life_draw(L);
    else life_draw4(L);
    L-&gtdrawn++;
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    mtx_unlock(&L-&gtmtx);

    x0 = L-&gtx0;
    x1 = L-&gtx1;
    // no need to draw too quickly
    life_sleep(1.0/40);
  }
  return 0;
}

// This number of consecutive states that are already known (that is,
// hashed in) decides that this sequence of states is cyclic.
enum { repetition = 10, };

static
int account_thread(void* Lv) {
  /* Nobody should ever wait for this thread. */
  thrd_detach(thrd_current());
  life*restrict L = Lv;
  while (!L-&gtfinished) {
    // Blocks until there is work
    mtx_lock(&L-&gtmtx);
    while (!L-&gtfinished && (L-&gtaccounted == L-&gtiteration))
      life_wait(&L-&gtacco, &L-&gtmtx);

    // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    life_account(L);
    if ((L-&gtlast + repetition) &lt L-&gtaccounted) {
      L-&gtfinished = true;
    }
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cnd_signal(&L-&gtupda);
    mtx_unlock(&L-&gtmtx);
  }
  return 0;
}

static
int input_thread(void* Lv) {
  /* Nobody should ever wait for this thread. */
  thrd_detach(thrd_current());
  termin_unbuffered();
  life*restrict L = Lv;
  enum { len = 32, };
  char command[len];
  do {
    int c = getchar();
    command[0] = c;
    switch(c) {
    case GO_LEFT : life_advance(L,  0, -1); break;
    case GO_RIGHT: life_advance(L,  0, +1); break;
    case GO_UP   : life_advance(L, -1,  0); break;
    case GO_DOWN : life_advance(L, +1,  0); break;
    case GO_HOME : L-&gtx0 = 1; L-&gtx1 = 1;    break;
    case ESCAPE  :
      ungetc(termin_translate(termin_read_esc(len, command)), stdin);
      continue;
    case '+':      if (L-&gtframes &lt 128) L-&gtframes++; continue;
    case '-':      if (L-&gtframes &gt 1)   L-&gtframes--; continue;
    case ' ':
    case 'b':
    case 'B':
      mtx_lock(&L-&gtmtx);
      // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
      life_birth9(L);
      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      mtx_unlock(&L-&gtmtx);
      break;
    case 'q':
    case 'Q':
    case EOF:      goto FINISH;
    }
    cnd_signal(&L-&gtdraw);
  } while (!(L-&gtfinished || feof(stdin)));
 FINISH:
  L-&gtfinished = true;
  return 0;
}

enum { n = 60, m = 160 };

bool M[n][m] = {
 { 0 },
 { 0 },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0 },
 { 0 },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0 },
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, },
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0 },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0 },
 { 0 },
 { 0 },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0},
 { 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0 },
 { 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0 },
 { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0 },
 { 0 },
};

life L = LIFE_INITIALIZER;

void B9_atexit(void) {
  /* Puts the board in a nice final picture */
  L.iteration = L.last;
  life_draw(&L);
  life_destroy(&L);
}

int main(int argc, char* argv[argc+1]) {
  /* Uses command-line arguments for the size of the board */
  size_t n0 = 30;
  size_t n1 = 80;
  if (argc &gt 1) n0 = strtoull(argv[1], 0, 0);
  if (argc &gt 2) n1 = strtoull(argv[2], 0, 0);
  /* Create an object that holds the game's data. */
  life_init(&L, n0, n1, M);
  atexit(B9_atexit);
  /* Creates four threads that operate on the same object and
     discards their IDs */
  thrd_create(&(thrd_t){0}, update_thread,  &L);
  thrd_create(&(thrd_t){0}, draw_thread,    &L);
  thrd_create(&(thrd_t){0}, input_thread,   &L);
  /* Ends this thread nicely and lets the threads go on nicely */
  thrd_exit(0);
}
/* This may look like nonsense, but really is -*- mode: C -*- */

/* The main thing that this program does. */
void main() {
  // Declarations
  int i;
  double A[5] = {
    9.0,
    2.9,
    3.E+25,
    .00007,
  };

  // Doing some work
  for (i = 0; i &lt 5; ++i) {
     printf("element %d is %g, \tits square is %g\n", /*@\label{printf-start-badly}*/
            i,
            A[i],
            A[i]*A[i]);                               /*@\label{printf-end-badly}*/
  }

  return 0;                                           /*@\label{main-return-badly}*/
}
#include &ltctype.h&gt
#include &ltsetjmp.h&gt
#include &ltstdbool.h&gt
#include &ltstdio.h&gt
#include &ltstdlib.h&gt
#include "sighandler.h"

/*
 * Because the parser is implemented here doesn't take care of
 * strings, character constants or comments, we hide the { } inside
 * macros.
 */
#define LEFT '{'
#define RIGHT '}'

/**
 ** @brief Initial string to indent a line.
 **/
static char const head[] = "&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt| ";

/**
 ** @brief skip any amount of spaces, tabs or newlines in @a s
 **/
static
char const* skipspace(char const* s) {
  while (isspace(s[0]))
    ++s;
  return s;
}

/**
 ** @brief exceptional states of the parse algorithm
 **/
enum state {
  execution = 0,    //*&lt normal execution
  plusL,            //*&lt too many left parenthesis
  plusR,            //*&lt too many right parenthesis
  tooDeep,          //*&lt nesting too deep to handle
  eofOut,           //*&lt end of output
  interrupted,      //*&lt interrupted by signal
};

/**
 ** @brief output end of line and eat all subsequent spaces on input
 **/
static
char const* end_line(char const* s, jmp_buf jmpTarget) {
  if (putchar('\n') == EOF) longjmp(jmpTarget, eofOut);
  return skipspace(s);
}

typedef enum state state;

/**
 ** @brief Keep track of the last signal that interrupted us.
 **/
static sig_atomic_t volatile interrupt = 0;

/**
 ** @brief Keep track of the depth at which an error was detected.
 **/
static unsigned volatile deepest = 0;

static
char const* descend1(char const act[static 1],
                     unsigned depth,
                     size_t len, char buffer[len],
                     jmp_buf jmpTarget) {
  if (depth+2 &gt sizeof head) longjmp(jmpTarget, tooDeep);
 NEW_LINE:                                   // loop on output
  while (!act[0]) {                          // loop for input
    if (interrupt) longjmp(jmpTarget, interrupted);
    act = fgets(buffer, len, stdin);
    if (!act) {                              // end of stream
      deepest = depth;
      longjmp(jmpTarget, plusL);
    }
    act = skipspace(act);
  }
  // act is never 0 from here on
  fputs(&head[sizeof head - (depth + 3)], stdout);    // header
  for (; act[0]; ++act) {     // remainder of the line
    switch (act[0]) {
    case LEFT:                       // descend on left brace
      act = end_line(act+1, jmpTarget);
      act = descend1(act, depth+1, len, buffer, jmpTarget);
      act = end_line(act+1, jmpTarget);
      goto NEW_LINE;
    case RIGHT:                      // return on right brace
      return act;
    default:                         // print char and go on
      putchar(act[0]);
    }
  }
  goto NEW_LINE;
}

static
void descend0(size_t len, char buffer[len], jmp_buf jmpTarget) {
  char const* act = 0;
  NEW_LINE:                                   // loop on output
  do {                                        // loop for input
    if (interrupt) longjmp(jmpTarget, interrupted);
    act = fgets(buffer, len, stdin);
    if (!act) return;
    act = skipspace(act);
  } while (!act[0]);
  // act is never 0 from here on
  fputs(&head[sizeof head - 3], stdout);    // header
  for (; act[0]; ++act) {             // remainder of the line
    switch (act[0]) {
    case LEFT:                        // descend on left brace
      act = end_line(act+1, jmpTarget);
      act = descend1(act, 1, len, buffer, jmpTarget);
      act = end_line(act+1, jmpTarget);
      goto NEW_LINE;
    case RIGHT:                      // right brace is an error
      longjmp(jmpTarget, plusR);
    default:                         // print char and go on
      if (putchar(act[0]) == EOF) longjmp(jmpTarget, eofOut);
    }
  }
  goto NEW_LINE;
}

enum { maxline = 256 };

void basic_blocks(void) {
  char buffer[maxline];
  char const* format =
    "All %0.0d%c %c blocks have been closed correctly\n";
  jmp_buf jmpTarget;
  switch (setjmp(jmpTarget)) {
  case 0:
    deepest = 0;
    descend0(maxline, buffer, jmpTarget);
    break;
  case plusL:
    format =
      "Warning: %d %c %c blocks have not been closed properly\n";
    break;
  case plusR:
    format =
      "Error: closing too many (%d) %c %c blocks\n";
    break;
  case tooDeep:
    format =
      "Error: nesting (%d) of %c %c blocks is too deep\n";
    break;
  case eofOut:
    format =
      "Error: EOF for stdout at nesting (%d) of %c %c blocks\n";
    break;
  case interrupted:
    format =
      "Interrupted at level %d of %c %c block nesting\n";
    break;
  default:;
    format =
      "Error: unknown error within (%d) %c %c blocks\n";
  }
  fflush(stdout);
  fprintf(stderr, format, deepest, LEFT, RIGHT);
  if (interrupt) {
    SH_PRINT(stderr, interrupt,
             "is somebody trying to kill us?");
    raise(interrupt);
  }
}

/**
 ** @brief a minimal signal handler
 **
 ** After updating the signal count, for most signals this
 ** simply stores the signal value in "interrupt" and returns.
 **/
static void signal_handler(int sig) {
  sh_count(sig);
  switch (sig) {
  case SIGTERM: quick_exit(EXIT_FAILURE);
  case SIGABRT: _Exit(EXIT_FAILURE);
#ifdef SIGCONT
    // continue normal operation
  case SIGCONT: return;
#endif
  default:
    /* reset the handling to its default */
    signal(sig, SIG_DFL);
    interrupt = sig;
    return;
  }
}

// Will point to the command line arguments
static char** lastOpen = 0;

// Check if we were in the middle of an operatio
void doAtExit(void) {
  if (lastOpen && lastOpen[0]) {
    fprintf(stderr, "\n***********\nabnormal exit, last open file was %s\n", lastOpen[0]);
  }
}

int main(int argc, char* argv[argc+1]) {
  // ensure that stdout is line buffered
  if (setvbuf(stdout, 0, _IOLBF, maxline + sizeof head + 2)) {
    fputs("we could not establish line buffering for stdout, terminating.", stderr);
    return EXIT_FAILURE;
  }

  // establish exit handlers
  atexit(doAtExit);
  at_quick_exit(doAtExit);

  // establish signal handlers
  for (unsigned i = 1; i &lt sh_known; ++i)
    sh_enable(i, signal_handler);

  // if there are no command line arguments, read from stdin
  lastOpen = argv;
  if (argc &lt 2) goto RUN;

  // run basic_blocks for each command line argument
  for (++lastOpen; lastOpen[0]; ++lastOpen) {
    if (!freopen(lastOpen[0], "r", stdin)) {
      perror(lastOpen[0]);
      return EXIT_FAILURE;
    }
    printf("++++++++++ %s +++++++++++\n", lastOpen[0]);
  RUN:
    basic_blocks();
  }
  return EXIT_SUCCESS;
}
#include &ltctype.h&gt
#include &ltsetjmp.h&gt
#include &ltstdbool.h&gt
#include &ltstdio.h&gt
#include &ltstdlib.h&gt
#include "sighandler.h"

/*
 * Because the parser is implemented here, and doesn't take care of
 * strings, character constants, or comments, we hide the { } inside
 * macros.
 */
#define LEFT '{'
#define RIGHT '}'

/**
 ** @brief Initial string to indent a line
 **/
static char const head[] = "&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt&gt| ";

/**
 ** @brief Skips any number of spaces, tabs, or newlines in @a s
 **/
static
char const* skipspace(char const* s) {
  while (s && isspace(s[0])) {
    ++s;
  }
  return s;
}

/**
 ** @brief Exceptional states of the parse algorithm
 **/
enum state {
  execution = 0,    //*&lt Normal execution
  plusL,            //*&lt Too many left braces
  plusR,            //*&lt Too many right braces
  tooDeep,          //*&lt Nesting too deep to handle
  eofOut,           //*&lt End of output
  interrupted,      //*&lt Interrupted by a signal
};

/**
 ** @brief Outputs end of line and eats all subsequent spaces on input
 **/
static
char const* end_line(char const* s, jmp_buf jmpTarget) {
  if (putchar('\n') == EOF) longjmp(jmpTarget, eofOut);
  return skipspace(s);
}

typedef enum state state;

/**
 ** @brief Keeps track of the last signal that interrupted us
 **/
static sig_atomic_t volatile interrupt = 0;

static
char const* descend(char const* act,
                    unsigned dp[restrict static 1], // Bad
                    size_t len, char buffer[len],
                    jmp_buf jmpTarget) {
  if (dp[0]+3 &gt sizeof head) longjmp(jmpTarget, tooDeep);
  ++dp[0];/*@\label{lab:incr-rec}*/
 NEW_LINE:                             // Loops on output
  while (!act || !act[0]) {            // Loops for input
    if (interrupt) longjmp(jmpTarget, interrupted);
    act = skipspace(fgets(buffer, len, stdin));
    if (!act) {                        // End of stream
      if (dp[0] != 1) longjmp(jmpTarget, plusL);
      else goto ASCEND;
    }
  }
  fputs(&head[sizeof head - (dp[0] + 2)], stdout); // Header

  for (; act && act[0]; ++act) { // Remainder of the line
    switch (act[0]) {            /*@\label{lab:switch-char}*/
    case LEFT:                   // Descends on left brace
      act = end_line(act+1, jmpTarget);
      act = descend(act, dp, len, buffer, jmpTarget);/*@\label{lab:descend}*/
      act = end_line(act+1, jmpTarget);
      goto NEW_LINE;
    case RIGHT:                  // Returns on right brace
      if (dp[0] == 1) longjmp(jmpTarget, plusR);
      else goto ASCEND;
    default:                     // Prints char and goes on
      putchar(act[0]);
    }
  }
  goto NEW_LINE;
 ASCEND:
  --dp[0];/*@\label{lab:decr-rec}*/
  return act;
}

enum { maxline = 256 };

void basic_blocks(void) {
  char buffer[maxline];
  unsigned depth = 0;
  char const* format =
    "All %0.0d%c %c blocks have been closed correctly\n";
  jmp_buf jmpTarget;
  switch (setjmp(jmpTarget)) {
  case 0:
    descend(0, &depth, maxline, buffer, jmpTarget);
    break;
  case plusL:
    format =
      "Warning: %d %c %c blocks have not been closed properly\n";
    break;
  case plusR:
    format =
      "Error: closing too many (%d) %c %c blocks\n";
    break;
  case tooDeep:
    format =
      "Error: nesting (%d) of %c %c blocks is too deep\n";
    break;
  case eofOut:
    format =
      "Error: EOF for stdout at nesting (%d) of %c %c blocks\n";
    break;
  case interrupted:
    format =
      "Interrupted at level %d of %c %c block nesting\n";
    break;
  default:;
    format =
      "Error: unknown error within (%d) %c %c blocks\n";
  }
  fflush(stdout);
  fprintf(stderr, format, depth, LEFT, RIGHT);
  if (interrupt) {
    SH_PRINT(stderr, interrupt,
             "is somebody trying to kill us?");
    raise(interrupt);
  }
}

/**
 ** @brief A minimal signal handler
 **
 ** After updating the signal count, for most signals this
 ** simply stores the signal value in "interrupt" and returns.
 **/
static void signal_handler(int sig) {
  sh_count(sig);
  switch (sig) {
  case SIGTERM: quick_exit(EXIT_FAILURE);
  case SIGABRT: _Exit(EXIT_FAILURE);
#ifdef SIGCONT
    // continue normal operation
  case SIGCONT: return;
#endif
  default:
    /* reset the handling to its default */
    signal(sig, SIG_DFL);
    interrupt = sig;
    return;
  }
}

// Will point to the command-line arguments
static char** lastOpen = 0;

// Checks if we were in the middle of an operation
void doAtExit(void) {
  if (lastOpen && lastOpen[0]) {
    fprintf(stderr, "\n***********\nabnormal exit, last open file was %s\n", lastOpen[0]);
  }
}

int main(int argc, char* argv[argc+1]) {
  // Ensures that stdout is line buffered
  if (setvbuf(stdout, 0, _IOLBF, maxline + sizeof head + 2)) {
    fputs("we could not establish line buffering for stdout, terminating.", stderr);
    return EXIT_FAILURE;
  }

  // Establishes exit handlers
  atexit(doAtExit);
  at_quick_exit(doAtExit);

  // Establishes signal handlers
  for (unsigned i = 1; i &lt sh_known; ++i)
    sh_enable(i, signal_handler);

  // If there are no command-line arguments, reads from stdin
  lastOpen = argv;
  if (argc &lt 2) goto RUN;

  // Runs basic_blocks for each command-line argument
  for (++lastOpen; lastOpen[0]; ++lastOpen) {
    if (!freopen(lastOpen[0], "r", stdin)) {
      perror(lastOpen[0]);
      return EXIT_FAILURE;
    }
    printf("++++++++++ %s +++++++++++\n", lastOpen[0]);
  RUN:
    basic_blocks();
  }
  return EXIT_SUCCESS;
}
#include &ltstdlib.h&gt
#include &ltstdio.h&gt
#include &lterrno.h&gt

enum { buf_max = 32, };

int main(int argc, char* argv[argc+1]) {
  int ret = EXIT_FAILURE;
  char buffer[buf_max] = { 0 };
  for (int i = 1; i &lt argc; ++i) {        // Processes args
    FILE* instream = fopen(argv[i], "r"); // as filenames
    if (instream) {
      while (fgets(buffer, buf_max, instream)) {
        fputs(buffer, stdout);
      }
      fclose(instream);
      ret = EXIT_SUCCESS;
    } else {
      /* Provides some error diagnostic. */
      fprintf(stderr, "Could not open %s: ", argv[i]);
      perror(0);
      errno = 0;                       // Resets the error code
    }
  }
  return ret;
}
#include &ltstdlib.h&gt
#include &ltstring.h&gt
#include "circular.h"

/** @brief the hidden implementation of the circular buffer type */
struct circular {
  size_t start;    /**&lt Position of element 0 */
  size_t len;      /**&lt Number of elements stored */
  size_t max_len;  /**&lt Maximum capacity */
  double* tab;     /**&lt Array holding the data */
};

circular* circular_init(circular* c, size_t max_len) {
  if (c) {
    if (max_len) {
      *c = (circular){
        .max_len = max_len,
        .tab = malloc(sizeof(double[max_len])),
      };
        // Allocation failed.
      if (!c-&gttab) c-&gtmax_len = 0;
    } else {
      *c = (circular){ 0 };
    }
  }
  return c;
}

void circular_destroy(circular* c) {
  if (c) {
    free(c-&gttab);
    circular_init(c, 0);
  }
}

circular* circular_new(size_t len) {
  return circular_init(malloc(sizeof(circular)), len);
}

void circular_delete(circular* c) {
  circular_destroy(c);
  free(c);
}


size_t circular_getlength(circular* c) {
  return c ? c-&gtlen : 0;
}

static size_t circular_getpos(circular* c, size_t pos) {
  pos += c-&gtstart;
  pos %= c-&gtmax_len;
  return pos;
}

circular* circular_append(circular* c, double value) {
  if (c) {
    double* where = circular_element(c, c-&gtlen);
    if (where) {
      *where = value;
      ++c-&gtlen;
      return c;
    }
  }
  return 0;
}

double* circular_element(circular* c, size_t pos) {
  double* ret = 0;
  if (c) {
    if (pos &lt c-&gtmax_len) {
      pos = circular_getpos(c, pos);
      ret = &c-&gttab[pos];
    }
  }
  return ret;
}

double circular_pop(circular* c) {
  double ret = 0.0;
  if (c && c-&gtlen) {
    double* p = circular_element(c, 0);
    if (p) ret = *p;
    ++c-&gtstart;
    --c-&gtlen;
  }
  return ret;
}



circular* circular_resize(circular* c, size_t nlen) {
  if (c) {
    size_t len = c-&gtlen;
    if (len &gt nlen) return 0;
    size_t olen = c-&gtmax_len;
    if (nlen != olen) {
      size_t ostart = circular_getpos(c, 0);
      size_t nstart = ostart;
      double* otab = c-&gttab;
      double* ntab;
      if (nlen &gt olen) {
        ntab = realloc(c-&gttab, sizeof(double[nlen]));
        if (!ntab) return 0;
        // Two separate chunks
        if (ostart+len &gt olen) {
          size_t ulen = olen - ostart;
          size_t llen = len - ulen;
          if (llen &lt= (nlen - olen)) {
            /* Copy the lower one up after the old end. */ /*@\label{cpy-lowchunk}*/
            memcpy(ntab + olen, ntab,
                   llen*sizeof(double));
          } else {
            /* Move the upper one up to the new end. */ /*@\label{cpy-hichunk}*/
            nstart = nlen - ulen;
            memmove(ntab + nstart, ntab + ostart,
                    ulen*sizeof(double));
          }
        }
      } else {
        if (ostart+len &gt olen) {
          // Two separate chunks; mv the upper one down to the new end.
          size_t ulen = olen - ostart;
          nstart = nlen - ulen;
          memmove(otab + nstart, otab + ostart, ulen*sizeof(double));
        } else {
          // A single chunk
          if (ostart + len &gt nlen) {
            // Reallocation cuts the existing chunk in two.
            memmove(otab, otab + ostart, len*sizeof(double));
            nstart = 0;
          }
        }
        // Now all data is saved in the conserved part of the array.
        ntab = realloc(c-&gttab, sizeof(double[nlen]));
        // If realloc fails in this case (would be weird), just overrule it.
        if (!ntab) ntab = otab;
      }
      *c = (circular){
        .max_len = nlen,
        .start = nstart,
        .len = len,
        .tab = ntab,
      };
    }
  }
  return c;
}

void circular_fput(circular* c, FILE* s) {
  if (c) {
    size_t len = circular_getlength(c);
    double* tab = c-&gttab;
    if (tab) {
      fprintf(s, "%p+%zu (%zu+%zu):", (void*)tab, c-&gtmax_len, c-&gtstart, len);
      for (size_t i = 0; i &lt len; ++i) {
        fprintf(s, "\t%g", *circular_element(c, i));
      }
      fputc('\n', s);
      return;
    }
  }
  fputs("invalid circular\n", s);
}
#include &ltstdio.h&gt
#include &ltinttypes.h&gt
#include &ltcomplex.h&gt
#include "crash.h"

void enable_alignment_check(void);
typedef complex double cdbl;

int main(void) {
  enable_alignment_check();
  /* An overlay of complex values and bytes. */
  union {
    cdbl val[2];
    unsigned char buf[sizeof(cdbl[2])];
  } toocomplex = {
    .val = { 0.5 + 0.5*I, 0.75 + 0.75*I, },
  };
  printf("size/alignment: %zu/%zu\n",
         sizeof(cdbl), _Alignof(cdbl));
  /* Run over all offsets, and crash on misalignment. */
  for (size_t offset = sizeof(cdbl); offset; offset /=2) {
    printf("offset\t%zu:\t", offset);
    fflush(stdout);
    cdbl* bp = (cdbl*)(&toocomplex.buf[offset]); // align!
    printf("%g\t+%gI\t", creal(*bp), cimag(*bp));
    fflush(stdout);
    *bp *= *bp;
    printf("%g\t+%gI", creal(*bp), cimag(*bp));
    fputc('\n', stdout);
  }
}
#include &ltstdio.h&gt
#include &ltinttypes.h&gt

typedef union unsignedInspect unsignedInspect;
union unsignedInspect {
  unsigned val;
  unsigned char bytes[sizeof(unsigned)];
};
unsignedInspect twofold = { .val = 0xAABBCCDD, };

int main(void) {
  printf("value is 0x%.08X\n", twofold.val);
  for (size_t i = 0; i &lt sizeof twofold.bytes; ++i)
    printf("byte[%zu]: 0x%.02hhX\n", i, twofold.bytes[i]);
  unsigned val = 0xAABBCCDD;
  unsigned char* valp = (unsigned char*)&val;
  for (size_t i = 0; i &lt sizeof val; ++i)
    printf("byte[%zu]: 0x%.02hhX\n", i, valp[i]);
}
#include "esc.h"

void esc_move(FILE* f, int vert, int hori) {
  if (vert &gt 0) fprintf(f, ESC_CSI "%dB", vert);
  else if (vert &lt 0) fprintf(f, ESC_CSI "%dA", -vert);
  if (hori &gt 0) fprintf(f, ESC_CSI "%dC", hori);
  else if (hori &lt 0) fprintf(f, ESC_CSI "%dD", -hori);
}

void esc_goto(FILE* f, unsigned vert, unsigned hori) {
  fprintf(f, ESC_CSI "%u;%uH", vert, hori);
}
#include "euclid.h"

int main(int argc, char* argv[argc+1]) {
  size_t prev = 0;
  for (int i = 1; i &lt argc; ++i) {        // Processes args
    size_t act = strtoull(argv[i], 0, 0); // arg -&gt unsigned long long
    if (prev)
      printf("gcd(%zu, %zu) is %zu\n",
             prev, act, gcd(prev, act));
    prev = act;
  }
  return EXIT_SUCCESS;
}
#include &ltstdio.h&gt

unsigned i = 1;          /*@\label{line:decl-i-1}*/

int main(void) {
  unsigned i = 2;        /* A new object *//*@\label{line:decl-i-2}*/
  if (i) {
    extern unsigned i;   /* An existing object *//*@\label{line:decl-i-3}*/
    printf("%u\n", i);
  } else {
    printf("%u\n", i);
  }
}
#include &ltstdlib.h&gt
#include &ltstdio.h&gt

void fib2rec(size_t n, size_t buf[2]) {
  if (n &gt 2) {
    size_t res = buf[0] + buf[1];
    buf[1] = buf[0];
    buf[0] = res;
    fib2rec(n-1, buf);
  }
}

size_t fib2(size_t n) {
  size_t res[2] = { 1, 1, };
  fib2rec(n, res);
  return res[0];
}

int main(int argc, char* argv[argc+1]) {
  for (int i = 1; i &lt argc; ++i) {             // Processes args
    size_t const n = strtoull(argv[i], 0, 0);  // arg -&gt size_t
    printf("fib(%zu) is %zu\n",
           n, fib2(n));
  }
  return EXIT_SUCCESS;
}
#include &ltstdlib.h&gt
#include &ltstdio.h&gt

void fib2rec(size_t n, size_t buf[2]) {
  if (n) {
    size_t res = buf[0] + buf[1];
    buf[1] = buf[0];
    buf[0] = res;
    fib2rec(n-1, buf);
  }
}


size_t fib2(size_t n) {
  size_t res[2] = { 1, 1, };
  if (n &gt 2) fib2rec(n - 2, res);
  return res[0];
}

int main(int argc, char* argv[argc+1]) {
  for (int i = 1; i &lt argc; ++i) {             // process args
    size_t const n = strtoull(argv[i], 0, 0); // arg -&gt size_t
    printf("fib(%zu) is %zu\n",
           n, fib2(n));
  }
  return EXIT_SUCCESS;
}
#include &ltstdlib.h&gt
#include &ltstdio.h&gt

/**
 ** Rewrite the recursive Fibonacci such that it alternates the use of
 ** the buffers.
 **/

void fib2rec(size_t n, size_t buf[2]) {
  if (n) {
    buf[n%2] += buf[!(n%2)];
    fib2rec(n-1, buf);
  }
}


size_t fib2(size_t n) {
  size_t res[2] = { 1, 1, };
  if (n &gt 2) fib2rec(n - 2, res);
  return res[1];
}

int main(int argc, char* argv[argc+1]) {
  for (int i = 1; i &lt argc; ++i) {             // process args
    size_t const n = strtoull(argv[i], 0, 0); // arg -&gt size_t
    printf("fib(%zu) is %zu\n",
           n, fib2(n));
  }
  return EXIT_SUCCESS;
}
#include &ltstdlib.h&gt
#include &ltstdio.h&gt

/**
 ** Rewrite the recursive Fibonacci such that it unrolls two
 ** successive recursive calls.
 **/

void fib2rec(size_t n, size_t buf[2]) {
  if (n &gt 1) {
    buf[0] += buf[1];
    buf[1] += buf[0];
    fib2rec(n-2, buf);
  }
}

size_t fib2(size_t n) {
  size_t res[2] = { 1, 1, };
  if (n &gt 2) fib2rec(n-1, res);
  return res[!(n%2)];
}

int main(int argc, char* argv[argc+1]) {
  for (int i = 1; i &lt argc; ++i) {             // process args
    size_t const n = strtoull(argv[i], 0, 0); // arg -&gt size_t
    printf("fib(%zu) is %zu\n",
           n, fib2(n));
  }
  return EXIT_SUCCESS;
}
#include &ltstdlib.h&gt
#include &ltstdio.h&gt

/**
 ** Rewrite Fibonacci iteratively such that is proceeds in pairs of
 ** values and hopefully doesn't spill any of the variables to memory.
 **/

size_t fib2(size_t n) {
  register size_t x1 = 1;           // F(x1)   for x1 = (n+1)%2 + 1
  register size_t x2 = n%2 ? 1 : 2; // F(x1+1)
  for (register size_t i = (n-1)/2; i; --i) {
    x1 += x2;
    x2 += x1;
  }
  return x1;              // F(y) with y = x1 + 2*((n-1)/2)
                          //             = x1 + ((n-1)-((n+1)%2))
                          //             = ((n+1)%2 + 1)+((n-1)-((n+1)%2))
                          //             = n
}

int main(int argc, char* argv[argc+1]) {
  for (int i = 1; i &lt argc; ++i) {             // process args
    size_t const n = strtoull(argv[i], 0, 0); // arg -&gt size_t
    printf("fib(%zu) is %zu\n",
           n, fib2(n));
  }
  return EXIT_SUCCESS;
}
#include &ltstdlib.h&gt
#include &ltstdio.h&gt

size_t fib(size_t n) {
  if (n &lt 3)
    return 1;
  else
    return fib(n-1) + fib(n-2);
}


int main(int argc, char *argv[]) {
  for (int i = 1; i &lt argc; ++i) {             // Processes args
    size_t const n = strtoull(argv[i], 0, 0);  // arg -&gt size_t
    printf("fib(%zu) is %zu\n",
           n, fib(n));
  }
  return EXIT_SUCCESS;
}
#include &ltstdlib.h&gt
#include &ltstdio.h&gt

/* Compute Fibonacci number n with the help of a cache that may
   hold previously computed values. */
size_t fibCacheRec(size_t n, size_t cache[n]) {
  if (!cache[n-1]) {
    cache[n-1]
      = fibCacheRec(n-1, cache) + fibCacheRec(n-2, cache);
  }
  return cache[n-1];
}

size_t fibCache(size_t n) {
  if (n+1 &lt= 3) return 1;
  /* Set up a VLA to cache the values. */
  size_t cache[n];
  /* A VLA must be initialized by assignment. */
  cache[0] = 1; cache[1] = 1;
  for (size_t i = 2; i &lt n; ++i)
    cache[i] = 0;
  /* Call the recursive function. */
  return fibCacheRec(n, cache);
}

double goldenRatio(size_t n) {
  if (n+1 &lt= 3) return 1;
  size_t cache[n];
  cache[0] = 1;
  cache[1] = 1;
  for (size_t i = 2; i &lt n; ++i)
    cache[i] = 0;
  double ret = fibCacheRec(n, cache);
  return ret/fibCacheRec(n-1, cache);
}

int main(int argc, char* argv[argc+1]) {
  for (int i = 1; i &lt argc; ++i) {             // Processes args
    size_t const n = strtoull(argv[i], 0, 0);  // arg -&gt size_t
    double golden = goldenRatio(n);
    double control = golden*2.0-1.0;
    printf("fib(%zu) is %zu, golden ratio %.20g, control %.20g\n",
           n, fibCache(n), golden, control*control);
  }
  return EXIT_SUCCESS;
}
#include &ltstdlib.h&gt
#include &ltstdio.h&gt

typedef struct fibonaccipair fibonaccipair;

struct fibonaccipair {
  size_t prev;
  size_t act;
};

fibonaccipair fiboNext(fibonaccipair ret) {
  size_t res = ret.act + ret.prev;
  ret.prev = ret.act;
  ret.act = res;
  return ret;
}

fibonaccipair fibonacci2(size_t n, fibonaccipair ret) {
  if (n) {
    return fibonacci2(n-1, fiboNext(ret));
  } else
    return ret;
}

fibonaccipair fibonacci3(size_t n, fibonaccipair ret) {
  while (n --&gt 0) {
    ret = fiboNext(ret);
  }
  return ret;
}

size_t fibonacci(size_t n) {
  register fibonaccipair res = { 1, 1, };
  if (n &gt 2) res = fibonacci2(n - 2, res);
  return res.act;
}


int main(int argc, char* argv[argc+1]) {
  for (int i = 1; i &lt argc; ++i) {             // process args
    size_t const n = strtoull(argv[i], 0, 0); // arg -&gt size_t
    printf("fibonacci(%zu) is %zu\n",
           n, fibonacci(n));
  }
  return EXIT_SUCCESS;
}
#include &ltstdio.h&gt
#include &ltstdlib.h&gt
#include "generic.h"

/* "Instantiate" the inline functions of the "generic.h" header. */
double (min)(double a, double b);
long double (minl)(long double a, long double b);
float (minf)(float a, float b);
signed (maxs)(signed a, signed b);
unsigned (maxu)(unsigned a, unsigned b);
unsigned (maxus)(unsigned a, signed b);
unsigned (maxsu)(signed a, unsigned b);
signed long (maxsl)(signed long a, signed long b);
unsigned long (maxul)(unsigned long a, unsigned long b);
unsigned long (maxusl)(unsigned long a, signed long b);
unsigned long (maxsul)(signed long a, unsigned long b);
signed long long (maxsll)(signed long long a, signed long long b);
unsigned long long (maxull)(unsigned long long a, unsigned long long b);
unsigned long long (maxusll)(unsigned long long a, signed long long b);
unsigned long long (maxsull)(signed long long a, unsigned long long b);

int main(int argc, char* argv[argc+1]){
  if (argc &gt 1) {
    printf("testing strto functions: base 10 = %lu, general base = %llu\n",
           strtoul10(argv[2]), strtoull(argv[2]));
    long double a = strtold(argv[1]);
    printf("minimum of %Lg and 1.0f is %Lg\n",
           a, min(a, 1.0F));
    printf("minimum of %g and argc is %g\n",
           3.0, min(3.0, argc));
  }
  printf("maxof(1) = %d\n", maxof(1));
  printf("maxof(1.0) = %g\n", maxof(1.0));
  printf("maxof(long double) = %Lg\n", maxof(long double));
  printf("minof(1ul) = %lu\n", minof(1ul));
  printf("minof(1.0) = %g\n", minof(1.0));
  printf("minof(long double) = %Lg\n", minof(long double));
  printf("mix(1u, -1l) = %luul\n", mix(1u, -1l));
  printf("mix(-1, 1ul) = %luul\n", mix(-1, 1ul));
  printf("mix(-1, 1l) = %ldl\n", mix(-1, 1l));
  printf("mix(1u, 2ul) = %luul\n", mix(1u, 2ul));
  return EXIT_SUCCESS;
}
/* This may look like nonsense, but really is -*- mode: C -*- */
#include &ltstdlib.h&gt                                    /*@\label{include-stdlib}*/
#include &ltstdio.h&gt                                     /*@\label{include-stdio}*/

/* The main thing that this program does. */           /*@\label{C-comment}*/
int main(void) {                                       /*@\label{main-start}*/
  // Declarations
  double A[5] = {                                      /*@\label{array-declaration}*/
    [0] = 9.0,                                         /*@\label{designated-init}*/
    [1] = 2.9,
    [4] = 3.E+25,                                      /*@\label{scientific-notation}*/
    [3] = .00007,                                      /*@\label{comma-terminate}*/
  };

  // Doing some work                                   /*@\label{CPP-comment}*/
  for (size_t i = 0; i &lt 5; ++i) {                     /*@\label{for-loop}*/
     printf("element %zu is %g, \tits square is %g\n", /*@\label{printf-start}*/
            i,
            A[i],
            A[i]*A[i]);                                /*@\label{printf-end}*/
  }                                                    /*@\label{for-end}*/

  return EXIT_SUCCESS;                                 /*@\label{main-return}*/
}                                                      /*@\label{main-end}*/
#include &ltstdlib.h&gt
#include &ltstdio.h&gt

/* lower and upper iteration limits centered around 1.0 */
static double const eps1m01 = 1.0 - 0x1P-01;
static double const eps1p01 = 1.0 + 0x1P-01;
static double const eps1m24 = 1.0 - 0x1P-24;
static double const eps1p24 = 1.0 + 0x1P-24;

int main(int argc, char* argv[argc+1]) {
  for (int i = 1; i &lt argc; ++i) {        // process args
    double const a = strtod(argv[i], 0);  // arg -&gt double
    double x = 1.0;
    for (;;) {                    // by powers of 2
      double prod = a*x;
      if (prod &lt eps1m01) {
        x *= 2.0;
      } else if   (eps1p01 &lt prod) {
        x *= 0.5;
      } else {
        break;
      }
    }
    for (;;) {                    // Heron approximation
      double prod = a*x;
      if ((prod &lt eps1m24) || (eps1p24 &lt prod)) {
        x *= (2.0 - prod);
      } else {
        break;
      }
    }
    printf("heron: a=%.5e,\tx=%.5e,\ta*x=%.12f\n",
           a, x, a*x);
  }
  return EXIT_SUCCESS;
}
#include &ltstdlib.h&gt
#include &ltstdio.h&gt

int main(int argc, char* argv[argc+1]) {
  double const epsP1 = 1.0 + 1E-9;
  double const epsM1 = 1.0 - 1E-9;
  for (int i = 1; i &lt argc; ++i) {
    /* Read one command line argument as a double. */
    double const a = strtod(argv[i], 0);
    /* Compute some local constants. */
    double fact;
    double alow;
    double ahig;
    if (a &lt 1.0) {
      fact =  2.0;
      alow =  a;
      ahig =  1.0;
    } else {
      fact =  0.5;
      alow =  -a;
      ahig =  -1.0;
    }
    /* A first low quality estimate for the inverse. */
    double x = 1.0;
    /* Adapt x until it has the right magnitude. */
    while (alow*x &lt ahig) x *= fact;
    /* We are close, correct with the Heron factor. */
    for (double prod = a*x;
         ((prod &lt epsM1) || (epsP1 &lt prod));
         prod = a*x) {
      x *= (2.0 - prod);
    }
    printf("heron: a=%.5e,\tx=%.5e,\ta*x=%.12f\n",
           a, x, a*x);
  }
  return EXIT_SUCCESS;
}
#include "heron_k.h"

/**
 ** Simply works by repeated squaring.
 **/
double expk2(double a, unsigned k) {
  for (;;) {
    k /= 2u;
    if (!k) break;
    a *= a;
  }
  return a;
}

double expk_rec(double a, unsigned k) {
  switch (k)
  default: {
    if (k % 2u)
    case 3: {
      double ret = expk_rec(a, k/2u);
      ret *= ret;
      a *= ret;
    } else {
      /* If k is a power of 2, do something special. */
      if (k == (k & -k)) {
      case 4: a = expk2(a, k);
      } else {
        a = expk_rec(a, k/2u);
      case 2:
        a *= a;
      }
    }
  case 1:;
  }
  return a;
}

double frexp_np(double x, signed exp[static 1]) {
  if (x &lt 0.0) return -frexp_np(-x, exp);
  signed ret = 0;
  if (x &gt 0.0) {
    if (x &lt 0.5) {
      do {
        x *= 2.0;
        --ret;
      } while (x &lt 0.5);
    } else {
      while (x &gt= 1.0) {
        x *= 0.5;
        ++ret;
      }
    }
  }
  exp[0] = ret;
  return x;
}

double heron1_estimate(double a) {
  /* A first low quality estimate for the inverse. */
  signed e0; frexp_np(a, &e0);
  return
    (e0 &lt= 0
     ? expk_rec(2.0, 1-e0)
     : expk_rec(0.5, e0));
}

double heron1_estimate_dir_05(double a) {
  /* A table of double powers of 2. */
  /*Something like (2 &lt&lt (2 &lt&lt k)) if only that would be representable
     in an integer type. */
  double const tab[] = {
    0x1P+000,
    0x1P+001,
    0x1P+002,
    0x1P+004,
    0x1P+008,
    0x1P+016,
    0x1P+032,
    0x1P+064,
#if (DBL_MAX_EXP*FLT_RDXRDX) &gt 128
    0x1P+128,
#endif
#if (DBL_MAX_EXP*FLT_RDXRDX) &gt 256
    0x1P+256,
#endif
#if (DBL_MAX_EXP*FLT_RDXRDX) &gt 512
    0x1P+512,
#endif
#if (DBL_MAX_EXP*FLT_RDXRDX) &gt 1024
    0x1P+1024,
#endif
#if (DBL_MAX_EXP*FLT_RDXRDX) &gt 2048
    0x1P+2048,
#endif
#if (DBL_MAX_EXP*FLT_RDXRDX) &gt 4096
    0x1P+4096,
#endif
  };
  /* First estimate log2(log2(a)). This will be the most significant
     bit of the exponent that we are looking for. */
  enum { k_max = sizeof tab/sizeof tab[0], };
  unsigned k = 1u;
  while ((k &lt k_max) && (tab[k]*a &lt 1.0))
    ++k;
  double x = tab[k-1];
  a *= x;
  k -= 2u;
  /* Now test all the smaller bit positions in the exponent. */
  for (;k;--k) {
    if (tab[k]*a &lt 1.0) {
      a *= tab[k];
      x *= tab[k];
    }
  }
  return x;
}

double heron1_estimate_dir_10(double a) {
  /* A table of inverses of double powers of 2. */
  /* Something like 1.0/(2 &lt&lt (2 &lt&lt k)) if only that would be
     representable in an integer type. */
  double const tab[] = {
    0x1P-000,
    0x1P-001,
    0x1P-002,
    0x1P-004,
    0x1P-008,
    0x1P-016,
    0x1P-032,
    0x1P-064,
#if (DBL_MIN_EXP*FLT_RDXRDX) &lt -128
    0x1P-128,
#endif
#if (DBL_MIN_EXP*FLT_RDXRDX) &lt -256
    0x1P-256,
#endif
#if (DBL_MIN_EXP*FLT_RDXRDX) &lt -512
    0x1P-512,
#endif
#if (DBL_MIN_EXP*FLT_RDXRDX) &lt -1024
    0x1P-1024,
#endif
#if (DBL_MIN_EXP*FLT_RDXRDX) &lt -2048
    0x1P-2048,
#endif
#if (DBL_MIN_EXP*FLT_RDXRDX) &lt -4096
    0x1P-4096,
#endif
  };
  /* First estimate -log2(log2(a)). This will be the most significant
     bit of the exponent that we are looking for. */
  enum { k_max = sizeof tab/sizeof tab[0], };
  unsigned k = 1u;
  while ((k &lt k_max) && (tab[k]*a &gt= 0.5))
    ++k;
  double x = tab[k-1];
  a *= x;
  k -= 2u;
  /* Now test all the smaller bit positions in the exponent. */
  for (;k;--k) {
    if (tab[k]*a &gt= 0.5) {
      a *= tab[k];
      x *= tab[k];
    }
  }
  return x;
}

double heron1_estimate_dir(double a) {
  if (a &lt 0.5) return heron1_estimate_dir_05(a);
  else if (a &gt= 1.0) return heron1_estimate_dir_10(a);
  else return 1.0;
}

double heron1(double a) {
  double const epsP1 = 1.0 + 1E-9;
  double const epsM1 = 1.0 - 1E-9;
  double x = heron1_estimate_dir(a);
  /* We are close, correct with the Heron factor. */
  for (double prod = a*x;
       ((prod &lt epsM1) || (epsP1 &lt prod));
       prod = a*x) {
    x *= (2.0 - prod);
  }
  return x;
}

double expk(double a, signed k) {
  if (k &lt 0) return heron1(expk_rec(a, -k));
  if (k) return expk_rec(a, k);
  else return 1.0;
}

double heron(double a, signed k) {
  switch (k) {
  case 0: return 1.0;
  case 1: return a;
  }
  if (k &lt 0) return heron1(heron(a, -k));
  if (a &lt= 0.0) return 0.0;
  double const eps = 1E-12;
  double const k1 = heron1(k);
  double const a1 = heron1(a);
  double x = (1.0 + a)*k1;
  for (;;) {
    double xk1 = expk(x, k-1);
    double axk1 = a*heron1(xk1);
    if (fabs(1.0 - x*xk1*a1) &lt eps) break;
    x = ((k-1)*x + axk1)*k1;
  }
  return x;
}

/* A normal project would place the `main` in a different compilation
   unit. */
int main(int argc, char* argv[argc+1]) {
  /* Read the first command line argument for the exponent. */
  int k = strtol(argv[1], 0, 0);
  for (int i = 2; i &lt argc; ++i) {
    /* Read one command line argument as a double. */
    double const a = strtod(argv[i], 0);
    double const x = heron(a, k);
    signed e0; double m0 = frexp_np(x, &e0);
    signed e1; double m1 = frexp(x, &e1);
    printf("heron: a=%.5e,\tx=%.5e,\tx**k=%.20e, %gT%+d, %gT%+d\n",
           a, x, expk(x, k), m0, e0, m1, e1);
  }
  return EXIT_SUCCESS;
}
#include "life.h"
#include &ltstdlib.h&gt
#include &ltstdio.h&gt
#include &ltstdbool.h&gt
#include "termin.h"


void life_sleep(double s) {
  struct timespec duration = {
    .tv_sec = s,
    .tv_nsec = (s-(size_t)s)*1E9,
  };
  while (thrd_sleep(&duration, &duration)) {
    // Empty
  }
}

int life_wait(cnd_t* cnd, mtx_t* mtx) {
  struct timespec now;
  timespec_get(&now, TIME_UTC);
  now.tv_sec += 1;
  return cnd_timedwait(cnd, mtx, &now);
}

void life_advance(life* L, signed t0, signed t1);

static
bool life_alive(bool l, unsigned x) {
  return x == 3 || (l && x ==2);
}

// Computes the number of neighbors and stores them in B
void life_count(life* L) {
  size_t const n1 = L-&gtn1;
  bool (*const restrict M)[n1] = (void*)L-&gtMv;
  size_t const off0 = L-&gtoff0;
  size_t const off1 = L-&gtoff1;
  size_t const len0 = L-&gtlen0;
  size_t const len1 = L-&gtlen1;
  if (!L-&gtBv) L-&gtBv =  malloc(sizeof(unsigned char[len0][len1]));
  unsigned char (*restrict B)[len1] = L-&gtBv;
  for (size_t j0 = 0; j0 &lt len0; ++j0) {
    size_t i0 = off0 + j0;
    for (size_t j1 = 0; j1 &lt len1; ++j1) {
      size_t i1 = off1 + j1;
      B[j0][j1] =
        + M[i0-1][i1-1] + M[i0-1][i1] + M[i0-1][i1+1]
        + M[i0  ][i1-1] + 0           + M[i0  ][i1+1]
        + M[i0+1][i1-1] + M[i0+1][i1] + M[i0+1][i1+1];
    }
  }
}

size_t life_update(life* L) {
  size_t const n1 = L-&gtn1;
  bool (*const restrict M)[n1] = (void*)L-&gtMv;
  size_t const off0 = L-&gtoff0;
  size_t const off1 = L-&gtoff1;
  size_t const len0 = L-&gtlen0;
  size_t const len1 = L-&gtlen1;
  unsigned char (*restrict B)[len1] = L-&gtBv;
  size_t changed = 0;
  if (B) {
    for (size_t j0 = 0; j0 &lt len0; ++j0) {
      size_t i0 = off0 + j0;
      for (size_t j1 = 0; j1 &lt len1; ++j1) {
        size_t i1 = off1 + j1;
        bool newval = life_alive(M[i0][i1], B[j0][j1]);
        changed += (M[i0][i1] != newval);
        M[i0][i1] = newval;
      }
    }
  }
  L-&gtBv = 0;
  free(B);
  return changed;
}

void life_torus(life* L) {
  size_t const n0 = L-&gtn0;
  size_t const n1 = L-&gtn1;
  bool (*const restrict M)[n1] = L-&gtMv;
  for (size_t i0 = 1; i0 &lt n0; ++i0) {
    M[i0][0]    = M[i0][n1-2];
    M[i0][n1-1] = M[i0][1];
  }
  for (size_t i1 = 1; i1 &lt n1; ++i1) {
    M[0]   [i1] = M[n0-2][i1];
    M[n0-1][i1] = M[1]   [i1];
  }
  M[0]   [0]    = M[n0-2][n1-2];
  M[n0-1][0]    = M[1]   [n1-2];
  M[0]   [n1-1] = M[n0-2][1];
  M[n0-1][n1-1] = M[1]   [1];
}



#define DOT "â¦¿"
#define SPACE " "
#define WROOK ESC_TBLUE "â" ESC_NORMAL
#define BROOK ESC_TBLUE "â" ESC_NORMAL

static
void border(size_t m, int b) {
  fputs(ESC_TRED, stdout);
  fputs(ESC_BORDER[b & ~esc_right], stdout);
  for (size_t j = 0; j &lt m; ++j)
    fputs("â", stdout);
  fputs(ESC_BORDER[b & ~esc_left], stdout);
  fputs(ESC_NORMAL, stdout);
  esc_move(stdout, 1, -(m+2));
}

void life_draw(life* L) {
  size_t const n1 = L-&gtn1;
  bool (*const restrict M)[n1] = L-&gtMv;
  size_t const x0 = L-&gtx0;
  size_t const x1 = L-&gtx1;
  size_t const off0 = L-&gtoff0;
  size_t const off1 = L-&gtoff1;
  size_t const len0 = L-&gtlen0;
  size_t const len1 = L-&gtlen1;

  fputs(ESC_SAVE ESC_HOME ESC_HIDE, stdout);
  border(len1, esc_top|esc_right|esc_left);
  for (size_t i0 = off0; i0 &lt off0+len0; ++i0) {
    fputs(ESC_TRED, stdout);
    fputs(ESC_BORDER[esc_left], stdout);
    fputs(ESC_NORMAL, stdout);
    for (size_t i1 = off1; i1 &lt off1+len1; ++i1) {
      if (i1 == x1 && x0 == i0) fputs(M[i0][i1] ? WROOK : BROOK, stdout);
      else fputs(M[i0][i1] ? DOT : SPACE, stdout);
    }
    fputs(ESC_TRED, stdout);
    fputs(ESC_BORDER[esc_right], stdout);
    fputs(ESC_NORMAL, stdout);
    esc_move(stdout, 1, -(len1+2));
  }
  border(len1, esc_bottom|esc_right|esc_left);
  esc_goto(stdout, len0+3, 1);
  fprintf(stdout, ESC_CLEAR "%3zu FPS, %5zu iterations, %5zu birth9, %5zu constellations, " ESC_BOLD "%6.2f" ESC_NORMAL " quotient",
          L-&gtframes, L-&gtiteration, L-&gtbirth9, L-&gtconstellations, L-&gtconstellations*1.0/L-&gtbirth9);
  fputs(ESC_RESTORE ESC_SHOW, stdout);
  esc_goto(stdout, len0+4, 1);
}

void life_draw4(life* L) {
  size_t const n1 = L-&gtn1;
  bool (*const restrict M)[n1] = L-&gtMv;
  size_t const x0 = L-&gtx0;
  size_t const x1 = L-&gtx1;
  size_t const off0 = L-&gtoff0;
  size_t const off1 = L-&gtoff1;
  size_t const len0 = L-&gtlen0;
  size_t const len1 = L-&gtlen1;

  fputs(ESC_SAVE ESC_HOME ESC_HIDE, stdout);
  border(len1/2, esc_top|esc_right|esc_left);
  for (size_t i0 = off0; i0 &lt off0+len0; i0 += 2) {
    fputs(ESC_TRED, stdout);
    fputs(ESC_BORDER[esc_left], stdout);
    fputs(ESC_NORMAL, stdout);
    for (size_t i1 = off1; i1 &lt off1+len1; i1 += 2) {
      char const* str = 0;
      if ((i1 == x1 || i1+1 == x1) && (x0 == i0 || x0 == i0+1)) {
        // The cursor is a blue dot in the correct position, but the
        // three cell positions are also hidden. We grey them out.
        static char const*const corner[4] = {
          [0] = ESC_TBLUE ESC_BGREY "â" ESC_NORMAL,
          [1] = ESC_TBLUE ESC_BGREY "â" ESC_NORMAL,
          [2] = ESC_TBLUE ESC_BGREY "â" ESC_NORMAL,
          [3] = ESC_TBLUE ESC_BGREY "â" ESC_NORMAL,
        };
        unsigned ty = (x0%2)&lt&lt1 | (x1%2);
        str = corner[ty];
      } else {
        unsigned val = M[i0][i1]
          | (M[i0][i1+1] &lt&lt 1)
          | (M[i0+1][i1] &lt&lt 2)
          | (M[i0+1][i1+1] &lt&lt 3);
        str = ESC_BLOCK[val];
      }
      fputs(str, stdout);
    }
    fputs(ESC_TRED, stdout);
    fputs(ESC_BORDER[esc_right], stdout);
    fputs(ESC_NORMAL, stdout);
    esc_move(stdout, 1, -(len1/2+2));
  }
  border(len1/2, esc_bottom|esc_right|esc_left);
  esc_goto(stdout, len0/2+3, 1);
  fprintf(stdout, ESC_CLEAR "%3zu FPS, %5zu iterations, %5zu birth9, %5zu constellations, " ESC_BOLD "%6.2f" ESC_NORMAL " quotient",
          L-&gtframes, L-&gtiteration, L-&gtbirth9, L-&gtconstellations, L-&gtconstellations*1.0/L-&gtbirth9);
  fputs(ESC_RESTORE ESC_SHOW, stdout);
  esc_goto(stdout, len0+4, 1);
}

static
bool hashin(bool (*visited)[life_maxit], size_t hash) {
  bool ret = false;
  hash %= life_maxit;
  if (!(*visited)[hash]) {
    (*visited)[hash] = true;
    ret = true;
  }
  return ret;
}

void life_account(life* L) {
  size_t const n = L-&gtn0;
  size_t const m = L-&gtn1;
  bool (*const restrict M)[m] = L-&gtMv;
  // Computes a hash of the new state
  size_t hash = 0;
  for (size_t i = 1; i &lt n-2; ++i) {
    for (size_t j = 1; j &lt m-2; ++j) {
      hash = 37*hash + M[i][j] + 7;
    }
  }
  bool is_new = hashin(L-&gtvisited, hash);
  if (is_new) {
    L-&gtconstellations++;
    L-&gtlast = L-&gtaccounted;
  }
  L-&gtaccounted++;
}

void life_birth9(life* L) {
  size_t const n0 = L-&gtn0;
  size_t const n1 = L-&gtn1;
  size_t const x = L-&gtx0;
  size_t const y = L-&gtx1;
  bool (*const restrict M)[n1] = L-&gtMv;
  for (size_t i = n0-4; i &lt n0-1; ++i) {
    size_t xi = ((x+i)%(n0-2)) + 1;
    for (int j = n1-4; j &lt n1-1; ++j) {
      size_t yj = ((y+j)%(n1-2)) + 1;
      M[xi][yj] = true;
    }
  }
  L-&gtbirth9++;
}

life* life_init(life* L, size_t n, size_t m, bool mat[static n][m]) {
  if (L) {
    L-&gtn0 = n;
    L-&gtn1 = m;
    L-&gtoff0 = 1;
    L-&gtlen0 = n-2;
    L-&gtoff1 = 1;
    L-&gtlen1 = m-2;
    L-&gtvisited = calloc(sizeof(bool), life_maxit);
    L-&gtMv = mat;
    mtx_init(&L-&gtmtx, mtx_plain);
    cnd_init(&L-&gtdraw);
    cnd_init(&L-&gtacco);
    cnd_init(&L-&gtupda);
  }
  return L;
}

void life_destroy(life* L) {
  if (L) free(L-&gtvisited);
}
#include &ltstdio.h&gt

void fgoto(unsigned n) {
  unsigned j = 0;
  unsigned* p = 0;
  unsigned* q;
 AGAIN:
  if (p) printf("%u: p and q are %s, *p is %u\n",
                j,
                (q == p) ? "equal" : "unequal",
                *p);
  q = p;
  p = &((unsigned){ j, });
  ++j;
  if (j &lt= n) goto AGAIN;
}

void fgotoblock(unsigned n) {
  unsigned j = 0;
  unsigned* p = 0;
  unsigned* q;
 AGAIN:
  {
    if (p) printf("%u: p and q are %s, *p is %u\n",
                  j,
                  (q == p) ? "equal" : "unequal",
                  *p);
    q = p;
    p = &((unsigned){ j, });
    ++j;
    if (j &lt= n) goto AGAIN;
  }
}

__attribute__((noinline))
void ffor1(void) {
  unsigned j = 1;
  printf("%u: p and q are %s, *p is %u\n",
         j,
         "unequal",
         j-1);
}

__attribute__((noinline))
void fforn(unsigned n) {
  ffor1();
  for (unsigned j = 2; j &lt= n; ++j) {
    printf("%u: p and q are %s, *p is %u\n",
           j,
           "equal",
           j-1);
  }
}

void ffor(unsigned n) {
  switch (n) {
  case 0: break;
  case 1: ffor1(); break;
  default: fforn(n); break;
  }
}

void fVLA(unsigned n) {
  unsigned volatile j = 0;
  unsigned* p = 0;
  unsigned* q;
 AGAIN:
  {
    if (p) printf("%u: p and q are %s\n",
                  j,
                  (q == p) ? "equal" : "unequal");
    q = p;
    unsigned VLA[j+1];
    for (unsigned i = 0; i &lt= j; ++i)
      VLA[i] = j;
    p = VLA;
    ++j;
    if (j &lt= n) goto AGAIN;
  }
}



int main(int argc, char* argv[]) {
  fgoto(argc+1);
  fgotoblock(argc+1);
  ffor(argc+1);
}
char const A[] = { 'e', 'n', 'd', '\0', };
char const B[] = { 'e', 'n', 'd', '\0', };
char const* c = "end";
char const* d = "end";
char const* e = "friend";
char const* f = (char const[]){ 'e', 'n', 'd', '\0', };
char const* g = (char const[]){ 'e', 'n', 'd', '\0', };
#include &ltlocale.h&gt
#include &ltstdio.h&gt

/* You may have to unset the LANGUAGE environment variable for this to
   work properly. */

int main(int argc, char* argv[argc+1]) {
  perror("With C locale");
  if (!setlocale(LC_ALL, ""))
    perror("couldn't set locale");
  else
    perror("With default locale");
  if (!setlocale(LC_MESSAGES, "C"))
    perror("couldn't set locale");
  else
    perror("C locale, again");
  if (argv[1] && !setlocale(LC_MESSAGES, argv[1]))
    perror("couldn't set locale");
  else
    perror("new locale");
  printf("commandline argument was '%s'\n", argv[1]);
}
#include "macro_trace.h"
#include &lttgmath.h&gt
#include &ltstdlib.h&gt

char const* trace_skip(char const expr[static 1]);

void trace_values(FILE* s,
                  char const func[static 1],
                  char const line[static 1],
                  char const expr[static 1],
                  char const head[static 1],
                  size_t len, long double const arr[len]);


int main(int argc, char* argv[]) {
  double sum = argc &gt 1 ? strtod(argv[1], 0) : 0x1P-1;
  TRACE_PRINT0("my favorite variable: %g\n", sum);
  TRACE_PRINT1("my favorite variable: %g", sum);
  TRACE_PRINT2("my favorite variable: %g", sum);
  TRACE_VALUE0("my favorite value:", sum);
  TRACE_PTR0("my favorite pointer:", argv);
  TRACE_PTR1("my favorite pointer:", argv);
  TRACE_PRINT3("my favorite variable: %g", sum);
  TRACE_PRINT4("my favorite variable: %g", sum);
  TRACE_PRINT5("my favorite variable: %g", sum);
  TRACE_PRINT5("a good expression: %g", sum*argc);
  TRACE_PRINT6("a collection: %g, %i", sum, argc);
  TRACE_PRINT7("a string");
  TRACE_PRINT8("a collection: %g, %i", sum, argc);
  TRACE_PRINT8("another string");
  TRACE_PRINT9("a collection: %g, %i", sum*acos(0), argc);
  TRACE_VALUES("an untyped collection:", sum, argc, acos(0)*2);
  TRACE_VALUES("an untyped \"collection\":", sum, argc, acos(0)*2);
  TRACE_VALUES("just one element:", acos(0)*2);
  TRACE_VALUES("empty");
  TRACE_VALUES("\"empty\"");
  TRACE_VALUE1("my favorite value:", sum);
  TRACE_VALUE1("another value:", 0x1111111111111);
  TRACE_VALUE1("my favorite pointer:", argv);
}
#include &lterrno.h&gt
#include &ltlimits.h&gt
#include &ltlocale.h&gt
#include &ltstdbool.h&gt
#include &ltstdio.h&gt

#include "mbstrings.h"

/**
 ** @file
 ** @brief implement multibyte character string helpers
 **/

size_t mbrtow(wchar_t*restrict C, char const c[restrict static 1],
              mbstate_t*restrict state) {
  if (!state) state = MBSTATE;
  size_t len = -2;
  for (size_t maxlen = MB_LEN_MAX; len == -2; maxlen *= 2)
    len = mbrtowc(C, c, maxlen, state);
  if (len == -1) errno = 0;
  return len;
}

wint_t mbtow(char const*c) {
  wchar_t C = 0;
  size_t len = mbrtow(&C, c, MBSTATE);
  return (len == -1) ? WEOF : C;
}

size_t mbsrlen(char const*s, mbstate_t const*restrict state) {
  if (!state) state = MBSTATE;
  mbstate_t st = *state;
  size_t mblen = mbsrtowcs(0, &s, 0, &st);
  if (mblen == -1) errno = 0;
  return mblen;
}

wchar_t* mbsrdup(char const*s, mbstate_t const*restrict state) {
  size_t mblen = mbsrlen(s, state);
  if (mblen == -1) return 0;
  mbstate_t st =  state ? *state : *MBSTATE;
  wchar_t* S = malloc(sizeof(wchar_t[mblen+1]));
  /* We know that s converts well, so no error check */
  if (S) mbsrtowcs(S, &s, mblen+1, &st);
  return S;
}

#define SURROG0 0xD800L
#define SURROG1 (SURROG0 + 1024)
#define SURROG2 (SURROG1 + 1024)

int iswhighsurrogate(wint_t x) {
  return (SURROG0 &lt= x) && (x &lt SURROG1);
}

int iswlowsurrogate(wint_t x) {
  return (SURROG1 &lt= x) && (x &lt SURROG2);
}

int iswsurrogate(wint_t x) {
  return (SURROG0 &lt= x) && (x &lt SURROG2);
}

int iswvalid(wint_t x) {
  return x && x != WEOF && !iswsurrogate(x);
}

char const* mbsrwc(char const s[restrict static 1], mbstate_t*restrict state,
                   wchar_t C, size_t occurrence) {
  if (!C || C == WEOF) return 0;
  if (!state) state = MBSTATE;
  char const* ret = 0;

  mbstate_t st = *state;
  for (size_t len = 0; s[0]; s += len) {
    mbstate_t backup = st;
    wchar_t S = 0;
    len = mbrtow(&S, s, &st);
    if (!S) break;
    if (C == S) {
      *state = backup;
      ret = s;
      if (!occurrence) break;
      --occurrence;
    }
  }
  return ret;
}

char const* mbsrmb(char const s[static 1], mbstate_t*restrict state,
                   char const c[static 1], size_t occurrence) {
  if (!state) state = MBSTATE;
  wint_t C = mbtow(c);
  return mbsrwc(s, state, C, occurrence);
}

char const* mbsrrwc(char const s[restrict static 1], mbstate_t*restrict state,
                    wchar_t C) {
  return mbsrwc(s, state, C, -1);
}

char const* mbsrrmb(char const s[static 1], mbstate_t*restrict state,
                    char const c[static 1]) {
  return mbsrmb(s, state, c, -1);
}

char const* mbsrwcjump(char const s1[static 1], mbstate_t*restrict state,
                       size_t S2len, wchar_t const S2[S2len]) {
  if (!state) state = MBSTATE;
  mbstate_t st = *state;
  for (size_t i = 0; i &lt S2len; ++i) {
    wchar_t S1 = 0;
    s1 += mbrtow(&S1, s1, &st);
    if (S1 != S2[i]) return 0;
  }
  *state = st;
  return s1;
}


char const* mbsrwcs(char const s1[static 1], mbstate_t*restrict state,
                    wchar_t const S2[static 1]) {
  if (!state) state = MBSTATE;
  size_t S2len = wcslen(S2);
  switch (S2len) {
  case 0: return 0;
  case 1: return mbsrwc(s1, state, S2[0], 0);
  default:;
    /* Don't modify shift state until we found it. */
    mbstate_t rstate = *state;
    while (s1 && s1[0]) {
      s1 = mbsrwc(s1, &rstate, S2[0], 0);
      if (s1 && s1[0]) {
        /* s1 now is at a potential starting point */
        char const* ret = s1;
        mbstate_t tstate = rstate;
        if (mbsrwcjump(s1, &tstate, S2len, S2)) {
          *state = rstate;
          return ret;
        }
        /* Advance s1 to the next mb character. */
        s1 += mbrtow(0, s1, &rstate);
      }
    }
  }
  return 0;
}

char const* mbsrmbs(char const s1[static 1], mbstate_t*restrict state,
                    char const s2[static 1]) {
  if (!state) state = MBSTATE;
  wchar_t*restrict S2 = mbsrdup(s2, 0);
  if (!S2 || !S2[0]) return 0;
  s1 = mbsrwcs(s1, state, S2);
  free(S2);
  return s1;
}

char const* mbsrwcsskip(char const s1[static 1], mbstate_t*restrict state,
                        wchar_t const* S2){
  if (S2) {
    if (!state) state = MBSTATE;
    mbstate_t st = *state;
    for (size_t len; s1[0]; *state = st, s1 += len) {
      wchar_t S1[3] = { 0 };
      len = mbrtow(&S1[0], s1, &st);
      if (!S1[0]) break;
      if (!iswlowsurrogate(S1[0])) {
        if (!wcschr(S2, S1[0])) break;
      } else {
        len += mbrtow(&S1[1], s1, &st);
        if (!wcsstr(S2, S1)) break;
      }
    }
    *state = st;
  }
  return s1;
}

char const* mbsrskip(char const s1[static 1], mbstate_t*restrict state,
                     char const* s2) {
  if (!state) state = MBSTATE;
  wchar_t*restrict S2 = mbsrdup(s2, 0);
  s1 = mbsrwcsskip(s1, state, S2);
  free(S2);
  return s1;
}

size_t mbsspn(char const* s1, char const* s2) {
  return s1 ? mbsrskip(s1, 0, s2)-s1 : 0;
}

char const* mbsrskip_class(char const s1[static 1], mbstate_t*restrict state,
                           wcclass_t func) {
  if (!state) state = MBSTATE;
  for (size_t len; s1[0]; s1 += len) {
    wchar_t S1 = 0;
    len = mbrtow(&S1, s1, state);
    if (!S1 || !func(S1)) break;
  }
  return s1;
}

size_t mbsspn_class(char const* s1, wcclass_t func) {
  return s1 ? mbsrskip_class(s1, 0, func)-s1 : 0;
}

char const* mbsrskip_type(char const s1[static 1], mbstate_t*restrict state, wctype_t type) {
  if (!state) state = MBSTATE;
  for (size_t len; s1[0]; s1 += len) {
    wchar_t S1 = 0;
    len = mbrtow(&S1, s1, state);
    if (!S1 || !iswctype(S1, type)) break;
  }
  return s1;
}

size_t mbsspn_type(char const* s1, wctype_t type) {
  return s1 ? mbsrskip_type(s1, 0, type)-s1 : 0;
}

size_t mbsspn_name(char const* s1, char const name[static 1]) {
  return mbsspn_type(s1, wctype(name));
}

char const* mbsrwcscskip(char const s1[static 1], mbstate_t*restrict state,
                         wchar_t const* S2) {
  if (!state) state = MBSTATE;
  if (S2) {
    mbstate_t st = *state;
    for (size_t len; s1[0]; s1 += len) {
      wchar_t S1[3] = { 0 };
      len = mbrtow(&S1[0], s1, &st);
      if (!S1[0]) break;
      if (!iswlowsurrogate(S1[0])) {
        if (wcschr(S2, S1[0])) break;
      } else {
        len += mbrtow(&S1[1], s1, &st);
        if (wcsstr(S2, S1)) break;
      }
    }
    *state = st;
  }
  return s1;
}

char const* mbsrcskip(char const* s1, mbstate_t*restrict state, char const* s2) {
  if (!state) state = MBSTATE;
  wchar_t*restrict S2 = mbsrdup(s2, 0);
  s1 = mbsrwcscskip(s1, state, S2);
  free(S2);
  return s1;
}

size_t mbscspn(char const* s1, char const* s2) {
  return (s1 && s2) ? mbsrcskip(s1, 0, s2)-s1 : 0;
}


double mbsrtod(char const*restrict s1, mbstate_t*restrict state,
              char**restrict endptr) {
  if (!state) state = MBSTATE;
  return strtod(mbsrskip_class(s1, state, iswspace), endptr);
}

long double mbsrtold(char const*restrict s1, mbstate_t*restrict state, char**restrict endptr) {
  if (!state) state = MBSTATE;
  return strtold(mbsrskip_class(s1, state, iswspace), endptr);
}

long mbsrtol(char const*restrict s1, mbstate_t*restrict state, char**restrict endptr, int base) {
  if (!state) state = MBSTATE;
  return strtol(mbsrskip_class(s1, state, iswspace), endptr, base);
}

long long mbsrtoll(char const*restrict s1, mbstate_t*restrict state, char**restrict endptr, int base) {
  if (!state) state = MBSTATE;
  return strtoll(mbsrskip_class(s1, state, iswspace), endptr, base);
}

unsigned long mbsrtoul(char const*restrict s1, mbstate_t*restrict state, char**restrict endptr, int base) {
  if (!state) state = MBSTATE;
  return strtoul(mbsrskip_class(s1, state, iswspace), endptr, base);
}

unsigned long long mbsrtoull(char const*restrict s1, mbstate_t*restrict state, char**restrict endptr, int base) {
  if (!state) state = MBSTATE;
  return strtoull(mbsrskip_class(s1, state, iswspace), endptr, base);
}



char* mbsrmbsncpy(size_t n, char t[restrict n], mbstate_t const*restrict state,
                  char const s [restrict static 1]) {
  /* Don't do anything if s wouldn't fit entirely into t */
  char const* ep = memchr(s, 0, n);
  if (!ep) return 0;
  size_t slen = ep - s;
  /* If the target is in non-initial state, try to reset it. */
  if (!mbsinit(state)) {
    /* Now state is known to be non-null. */
    char buf[2*MB_LEN_MAX];
    mbstate_t st = *state;
    size_t len = wcrtomb(buf, 0, &st);
    /* See if shift characters plus s will fit into t. */
    if (slen+len &gt= n) return 0;
    /* write the bytes that end the shift state */
    memcpy(t, buf, len);
    t += len-1;
    n -= len-1;
  }
  if (slen &gt= n) return 0;
  memcpy(t, s, slen+1);
  return t + slen;
}

char* mbsrncpy(size_t n, char t[restrict n], mbstate_t*restrict tstate,
               char const s [restrict static 1], mbstate_t const*restrict sstate) {
  /* First check if the bytes can just be copied over. */
  if (mbsinit(sstate)) {
    char* ret = mbsrmbsncpy(n, t, tstate, s);
    if (ret) return ret;
  }
  char* tt = t;
  if (!tstate) tstate = MBSTATE;
  if (!sstate) sstate = MBSTATE;
  mbstate_t sst = *sstate;
  char buf[2*MB_LEN_MAX];
  for (size_t slen = 0; s[0] && n; s += slen) {
    wchar_t S[2] = { 0 };
    slen = mbrtowc(S, s, n, &sst);
    /* Here, wcsrtombs can't fail, but because of the different state
       of t, tlen may be larger than slen. */
    wchar_t const* Sp = S;
    mbstate_t tst = *tstate;
    size_t tlen = wcsrtombs(buf, &Sp, n, &tst);
    if (tlen &gt n) break;
    *tstate = tst;
    memcpy(tt, buf, tlen);
    if (!S[0]) break;
    tt += tlen;
    n -= tlen;
  }
  return tt;
}
#include &lterrno.h&gt
#include &ltlimits.h&gt
#include &ltlocale.h&gt
#include &ltstdbool.h&gt
#include &ltstdio.h&gt

#include "mbstrings.h"

enum {
  g_l = 1,
  g_r = 2,
  g_u = 4,
  g_d = 8,
};

#define MONTH(X)                                \
 (char const*[]){                               \
   [1] = "Jan",                                 \
     [2] = "Feb",                               \
     [3] = "Mar",                               \
     [4] = "Apr",                               \
     [5] = "Mai",                               \
     [6] = "Jun",                               \
     [7] = "Jul",                               \
     [8] = "Aug",                               \
     [9] = "Sep",                               \
     [10] = "Oct",                              \
     [11] = "Nov",                              \
     [12] = "Dec",                              \
     }[(X)%100]

#define STRINGIFY_(X) #X
#define STRINGIFY(X) STRINGIFY_(X)

#define YEAR(X)                                 \
(char const[5]){                                \
  STRINGIFY(X)[0],                              \
  STRINGIFY(X)[1],                              \
  STRINGIFY(X)[2],                              \
  STRINGIFY(X)[3],                              \
    }

#define VBAR "\u2502"      /**&lt a vertical bar character   */
#define HBAR "\u2500"      /**&lt a horizontal bar character */
#define TOPLEFT "\u250c"   /**&lt topleft corner character   */
#define TOPRIGHT "\u2510"  /**&lt topright corner character  */

/**
 ** @brief Draw multibyte strings @a start and @a end separated
 ** by a horizontal line.
 **/
void draw_sep(char const start[static 1],
              char const end[static 1]) {
  fputs(start, stdout);
  size_t slen = mbsrlen(start, 0);
  size_t elen = 90 - mbsrlen(end, 0);
  for (size_t i = slen; i &lt elen; ++i) fputs(HBAR, stdout);
  fputs(end, stdout);
  fputc('\n', stdout);
}

char const* g_table[] = {
  [0] = " ",
  [g_l] = "\u2574",
  [g_r] = "\u2576",
  [g_l|g_r] = "\u2500",
  [g_u] = "\u2575",
  [g_l|g_u] = "\u2518",
  [g_r|g_u] = "\u2514",
  [g_l|g_r|g_u] = "\u2534",
  [g_d] = "\u2577",
  [g_l|g_d] = "\u2510",
  [g_r|g_d] = "\u250c",
  [g_l|g_r|g_d] = "\u252c",
  [g_u|g_d] = "\u2502",
  [g_l|g_u|g_d] = "\u2524",
  [g_r|g_u|g_d] = "\u251c",
  [g_l|g_r|g_u|g_d] = "\u253c",
};

int main(void) {
  /* The first action of the executable should be locale switch. */
  char const* locC_ = setlocale(LC_CTYPE, 0);
  char locC[strlen(locC_)+1];
  strcpy(locC, locC_);

  setlocale(LC_ALL, "");
  /* Multibyte character printing only works after the locale
     has been switched. */
  draw_sep(TOPLEFT " Â© 2014 jÉnz ËgÊzËtÉt ", TOPRIGHT);

  char const* locLoc_ = setlocale(LC_CTYPE, 0);
  char locLoc[strlen(locLoc_)+1];
  strcpy(locLoc, locLoc_);
  char const strhello[] = "HÃ¤\u0131ÅÅÃ¶";
  char const u8hello[] = u8"HÃ¤\u0131ÅÅÃ¶";
  wchar_t const wcshello[] = L"HÃ¤\u0131ÅÅÃ¶";
  char const strvowel[] = "aeiouÃ¤Ã«Ã¯Ã¶Ã¼Ã¡Ã©Ã­Ã³ÃºÃ Ã¨Ã¬Ã²Ã¹Ã¦Å\u0131";
  char const u8vowel[] = u8"aeiouÃ¤Ã«Ã¯Ã¶Ã¼Ã¡Ã©Ã­Ã³ÃºÃ Ã¨Ã¬Ã²Ã¹Ã¦Å\u0131";
  wchar_t const wcsvowel[] = L"aeiouÃ¤Ã«Ã¯Ã¶Ã¼Ã¡Ã©Ã­Ã³ÃºÃ Ã¨Ã¬Ã²Ã¹Ã¦Å\u0131";
  char16_t c16butterfly[] = u"\U000272CA";
  char32_t c32butterfly[] = U"\U000272CA";
  wchar_t wbutterfly[] = L"\U000272CA";
  char u8butterfly[] = u8"\U000272CA";
  bool mbs_u8
    = (sizeof strvowel == sizeof u8vowel)
    && (!strcmp(strvowel, u8vowel))
    && (!strcmp("\U000272CA", u8"\U000272CA"));
  printf(VBAR "%ls world: switched \"%s\" \u21E8 \"%s\", multibyte strings are%s utf8, state%s\n",
         wcshello, locC, locLoc,
         mbs_u8 ? "" : " not",
         mblen(0, 0) ? "full" : "less");
  printf(VBAR "wchar_t (%ssigned) is %zu bit, wint_t (%ssigned) is %zu bit, WEOF is ",
         (WCHAR_MIN ? "" : "un"), sizeof(wchar_t)*CHAR_BIT,
         (WINT_MIN ? "" : "un"), sizeof(wint_t)*CHAR_BIT);
  if (WINT_MIN) printf("%lld\n", (long long)WEOF);
  else printf("%#llx\n", (unsigned long long)WEOF);
  printf(VBAR "wchar_t are Unicode code points as of %s %s, ",
# ifdef __STDC_ISO_10646__
         MONTH(__STDC_ISO_10646__),
         YEAR(__STDC_ISO_10646__)
# else
         "&ltunknown&gt",
         "&ltunknown&gt"
# endif
         );
# ifdef __STDC_MB_MIGHT_NEQ_WC__
  fputs("the basic character set is not extended to wchar_t\n", stdout);
# else
  fputs("wchar_t extends the basic character set\n", stdout);
# endif
#ifdef __STDC_UTF_16__
  fputs(VBAR "char16_t is UTF-16, ", stdout);
#else
  fputs("char16_t is not UTF-16, ", stdout);
#endif
#ifdef __STDC_UTF_32__
  fputs("char32_t is UTF-32\n", stdout);
#else
  fputs(VBAR "char32_t is not UTF-32\n", stdout);
#endif
  draw_sep(g_table[g_u|g_d|g_r], g_table[g_l|g_u|g_d]);
  printf(VBAR "testing character %ls, codepoint U+%lX, utf8 %hhx %hhx %hhx %hhx %hhx:\n",
         wbutterfly, 0x272CALU,
         u8butterfly[0], u8butterfly[1], u8butterfly[2], u8butterfly[3], u8butterfly[4]);
  printf(VBAR "\twchar_t,\tlength %zu,\t%s\n",
         (sizeof(wbutterfly)/sizeof(wbutterfly[0])) - 1,
         (sizeof(wbutterfly)/sizeof(wbutterfly[0])) == 2
         ? "one word encoding" : "surrogate encoding");
  printf(VBAR "\tchar32_t,\tlength %zu,\t%s\n",
         (sizeof(c32butterfly)/sizeof(c32butterfly[0])) - 1,
         (sizeof(c32butterfly)/sizeof(c32butterfly[0])) == 2
         ? "one word encoding" : "surrogate encoding");
  printf(VBAR "\tchar16_t,\tlength %zu,\t%s\n",
         (sizeof(c16butterfly)/sizeof(c16butterfly[0])) - 1,
         (sizeof(c16butterfly)/sizeof(c16butterfly[0])) == 2
         ? "one word encoding" : "surrogate encoding");
  if (sizeof(wchar_t) == sizeof(char32_t))
    printf(VBAR "\twchar_t and char32_t encoding %s\n",
           (sizeof(c32butterfly) == sizeof(wbutterfly)
            && c32butterfly[0] == wbutterfly[0]
            && c32butterfly[1] == wbutterfly[1]) ? "are equal" : "differ");
  else if (sizeof(wchar_t) == sizeof(char16_t))
    printf(VBAR "\twchar_t and char16_t encoding %s\n",
           (sizeof(c16butterfly) == sizeof(wbutterfly)
            && c16butterfly[0] == wbutterfly[0]
            && c16butterfly[1] == wbutterfly[1]) ? "are equal" : "differ");
  else
    printf(VBAR "\twchar_t, char32_t and char16_t types and encodings all differ\n");
  char const mbs0[] = u8"Å";
  char const* pos0 = mbsrmb(u8hello, 0, mbs0, 0);
  draw_sep(g_table[g_u|g_d|g_r], g_table[g_l|g_u|g_d]);
  printf(VBAR "search first:\tfound \"%s\",\tposition %td, %s\n", mbs0, pos0-u8hello, pos0);
  pos0 = mbsrmb(u8hello, 0, mbs0, 1);
  printf(VBAR "search second:\tfound \"%s\",\tposition %td, %s\n", mbs0, pos0-u8hello, pos0);
  char const mbs1[] = u8"Å";
  char const* pos1 = mbsrrmb(u8hello, 0, mbs1);
  printf(VBAR "search last:\tfound \"%s\",\tposition %td, %s\n", mbs1, pos1-u8hello, pos1);
  char const mbs2[] = u8"ÅÃ¶";
  char const* pos2 = mbsrmbs(u8hello, 0, mbs2);
  printf(VBAR "search needle:\tfound \"%s\",\tposition %td, %s\n", mbs2, pos2-u8hello, pos2);
  char const mbs3[] = u8" \u2003\u2002â";
  size_t pos3 = mbsspn_class(mbs3, iswspace);
  printf(VBAR "skip space:\tfound \"%s\",\tposition %zu, %s\n", mbs3, pos3, mbs3+pos3);
  draw_sep(g_table[g_u|g_d|g_r], g_table[g_l|g_u|g_d]);
  printf(VBAR "floats (locale):\t%g (C with .)\t%g (C with ,)\t%g (with .)\t%g (with ,)\n",
         strtod("9.3", 0), strtod("9,3", 0),
         mbsrtod("\u20039.3", 0, 0), mbsrtod("\u20039,3", 0, 0));
  draw_sep(g_table[g_u|g_d|g_r], g_table[g_l|g_u|g_d]);
  printf(VBAR "vowels\t%ls\n", wcsvowel);
  char u8vowel2[MB_LEN_MAX + sizeof u8vowel];
  char* partial = mbsrncpy(sizeof u8vowel-2, u8vowel2, 0, u8vowel, 0);
  if (partial[0]) partial[0] = 0;
  printf(VBAR "partial\t%s\n", u8vowel2);
  for (char const* s = strhello; s && s[0];) {
    s += mbscspn(s, strvowel);
    int vowels = mbsspn(s, strvowel);
    if (!vowels) {
      printf("bizarre, no vowels in remaining string %s", s);
      break;
    }
    printf(VBAR "%d bytes for vowel(s) %.*s\n", vowels, vowels, s);
    s += vowels;
  }
  draw_sep(g_table[g_u|g_r], g_table[g_l|g_u]);
}
#include &ltstdlib.h&gt
#include &ltstdio.h&gt
#include &ltstdint.h&gt
#include &ltstring.h&gt

/**
 ** @brief interpret string @a lbuf as a sequence of numbers
 ** represented with @a base
 **
 ** @return a newly allocated array of numbers as found in @a lbuf
 ** @param lbuf is supposed to be a string
 ** @param np if non-null, the count of numbers is stored in
 **   @c *np
 ** @param base value from 0 to 36, with the same interpretation
 **   as for @c strtoul
 **
 ** @remark The caller of this function is responsible to @c
 ** free the array that is returned.
 **/
size_t* numberline(size_t size, char const lbuf[restrict size],
                   size_t*restrict np, int base);

/**
 ** @brief read one text line of at most &ltcode&gtsize-1&lt/code&gt
 ** bytes. The &ltcode&gt'\n'&lt/code&gt character is replaced by @c 0.
 **
 ** @return s if an entire line was read
 ** successfully. Otherwise, @c 0 is returned and @a s contains
 ** a maximal partial line that could be read. @a s is null
 ** terminated.
 **/
char* fgetline(size_t size, char s[restrict size],
               FILE*restrict stream);


#include &ltlimits.h&gt
#include &lterrno.h&gt
#ifndef EFAULT
# define EFAULT EDOM
#endif
#ifndef EOVERFLOW
# define EOVERFLOW (EFAULT-EOF)
# if EOVERFLOW &gt INT_MAX
#  error EOVERFLOW constant is too large
# endif
#endif
#ifndef ENOMEM
# define ENOMEM (EOVERFLOW+EFAULT-EOF)
# if ENOMEM &gt INT_MAX
#  error ENOMEM constant is too large
# endif
#endif

/**
 ** @brief print a series of numbers @a nums on @a stream, using
 ** @c printf format @a form, separated by @a sep characters and
 ** terminated with a newline character.
 **
 ** @return the number of characters printed to @a stream, or a
 ** negative error value on error.
 **
 ** If @a len is @c 0, an empty line is printed and @c 1 is
 ** returned.
 **
 ** Possible error returns are:
 ** - &ltcode&gtEOF&lt/code&gt (which is negative) if @a stream was not
 **   ready to be written to
 ** - &ltcode&gt-EOVERFLOW&lt/code&gt if more than &ltcode&gtINT_MAX&lt/code&gt
 **   characters would have to be written, including the case
 **   that @a len is greater than &ltcode&gtINT_MAX&lt/code&gt.
 ** - &ltcode&gt-EFAULT&lt/code&gt if @a stream or @a numb are @c 0
 ** - &ltcode&gt-ENOMEM&lt/code&gt if a memory error occurred
 **
 ** This function leaves &ltcode&gterrno&lt/code&gt to the same value as
 ** occurred on entry.
 **/
int fprintnumbers(FILE*restrict stream,
                  char const form[restrict static 1],
                  char const sep[restrict static 1],
                  size_t len, size_t numb[restrict len]);

/**
 ** @brief print a series of numbers @a nums in @a buf, using @c
 ** printf format @a form, separated by @a sep characters and
 ** terminated with a newline character.
 **
 ** @return the number of characters printed to @a buf.
 **
 ** This supposes that @a tot and @a buf are big enough and
 ** that @a form is a format suitable to print @c size_t.
 **/
int sprintnumbers(size_t tot, char buf[restrict tot],
                  char const form[restrict static 1],
                  char const sep[restrict static 1],
                  size_t len, size_t nums[restrict len]);

static
size_t numberline_inner(char const*restrict act,
                        size_t numb[restrict], int base){
  size_t n = 0;
  for (char* next = 0; act[0]; act = next) {
    numb[n] = strtoull(act, &next, base);
    if (act == next) break;
    ++n;
  }
  return n;
}

size_t* numberline(size_t size, char const lbuf[restrict size],
                   size_t*restrict np, int base){
  size_t* ret = 0;
  size_t n = 0;
  /* Check for validity of the string, first. */
  if (memchr(lbuf, 0, size)) {
    /* The maximum number of integers encoded.
       To see that this may be as much look at
       the sequence 08 08 08 08 ... and suppose
       that base is 0. */
    ret = malloc(sizeof(size_t[1+(2*size)/3]));

    n = numberline_inner(lbuf, ret, base);

    /* Supposes that shrinking realloc will always succeed. */
    size_t len = n ? n : 1;
    ret = realloc(ret, sizeof(size_t[len]));
  }
  if (np) *np = n;
  return ret;
}

char* fgetline(size_t size, char s[restrict size],
               FILE*restrict stream){
  s[0] = 0;
  char* ret = fgets(s, size, stream);
  if (ret) {
    /* s is writable so can be pos. */
    char* pos = strchr(s, '\n');
    if (pos) *pos = 0;
    else ret = 0;
  }
  return ret;
}

static inline int error_cleanup(int err, int prev) {
  errno = prev;
  return -err;
}

int sprintnumbers(size_t tot, char buf[restrict tot],
                  char const form[restrict static 1],
                  char const sep[restrict static 1],
                  size_t len, size_t nums[restrict len]) {
  char* p = buf;   /* next position in buf */
  size_t const seplen = strlen(sep);
  if (len) {
    size_t i = 0;
    for (;;) {
      p += sprintf(p, form, nums[i]);
      ++i;
      if (i &gt= len) break;
      memcpy(p, sep, seplen);
      p += seplen;
    }
  }
  memcpy(p, "\n", 2);
  return (p-buf)+1;
}

int fprintnumbers(FILE*restrict stream,
                  char const form[restrict static 1],
                  char const sep[restrict static 1],
                  size_t len, size_t nums[restrict len]) {
  if (!stream)       return -EFAULT;
  if (len && !nums)  return -EFAULT;
  if (len &gt INT_MAX) return -EOVERFLOW;

  size_t tot = (len ? len : 1)*strlen(sep);
  int err = errno;
  char* buf = 0;

  if (len) {
    /* Count the chars for the numbers. */
    for (size_t i = 0; i &lt len; ++i)
      tot += snprintf(0, 0, form, nums[i]);
    /* We return int so we have to constrain the max size. */
    if (tot &gt INT_MAX) return error_cleanup(EOVERFLOW, err);
  }

  buf = malloc(tot+1);
  if (!buf) return error_cleanup(ENOMEM, err);

  sprintnumbers(tot, buf, form, sep, len, nums);
  /* print whole line in one go */
  if (fputs(buf, stream) == EOF) tot = EOF;
  free(buf);
  return tot;
}

int fprintnumbers_opt(FILE*restrict stream,
                  char const form[restrict static 1],
                  char const sep[restrict static 1],
                  size_t len, size_t nums[restrict len]) {
  if (!stream)       return -EFAULT;
  if (len && !nums)  return -EFAULT;
  if (len &gt INT_MAX) return -EOVERFLOW;

  int err = errno;
  size_t const seplen = strlen(sep);

  size_t tot = 0;
  size_t mtot = len*(seplen+10);
  char* buf = malloc(mtot);

  if (!buf) return error_cleanup(ENOMEM, err);

  for (size_t i = 0; i &lt len; ++i) {
    tot += sprintf(&buf[tot], form, nums[i]);
    ++i;
    if (i &gt= len) break;
    if (tot &gt mtot-20) {
      mtot *= 2;
      char* nbuf = realloc(buf, mtot);
      if (buf) {
        buf = nbuf;
      } else {
        tot = error_cleanup(ENOMEM, err);
        goto CLEANUP;
      }
    }
    memcpy(&buf[tot], sep, seplen);
    tot += seplen;
    if (tot &gt INT_MAX) {
      tot = error_cleanup(EOVERFLOW, err);
      goto CLEANUP;
    }
  }
  buf[tot] = 0;

  /* print whole line in one go */
  if (fputs(buf, stream) == EOF) tot = EOF;
 CLEANUP:
  free(buf);
  return tot;
}

int main(void) {
  char lbuf[256];
  for (;;) {
    if (fgetline(sizeof lbuf, lbuf, stdin)) {
      size_t n;
      size_t* nums = numberline(strlen(lbuf)+1, lbuf, &n, 0);
      int ret = fprintnumbers(stdout, "%#zX", ",\t", n, nums);
      if (ret &lt 0) return EXIT_FAILURE;
      free(nums);
    } else {
      if (lbuf[0]) {  /* a partial line has been read */
        for (;;) {
          int c = getc(stdin);
          if (c == EOF) return EXIT_FAILURE;
          if (c == '\n') {
            fprintf(stderr, "line too long: %s\n", lbuf);
            break;
          }
        }
      } else break;   /* regular end of input */
    }
  }
}
#include &ltstdio.h&gt

int main(void) {
  printf("%.20e %.20e\n",
         ((1.0E-13 + 1.0E-13)),
         (1.0E-13 + (1.0E-13 + 1.0)) - 1.0
         );
}
#include "rationals.h"

rat rat_get(long long num, unsigned long long denom) {
  rat ret = {
    .sign = (num &lt 0),
    .num = (num &lt 0) ? -num : num,
    .denom = denom,
  };
  return ret;
}

rat rat_get_normal(rat x) {
  size_t c = gcd(x.num, x.denom);
  x.num /= c;
  x.denom /= c;
  return x;
}

rat rat_get_extended(rat x, size_t f) {
  x.num *= f;
  x.denom *= f;
  return x;
}

rat rat_get_prod(rat x, rat y) {
  rat ret = {
    .sign = (x.sign != y.sign),
    .num = x.num * y.num,
    .denom = x.denom * y.denom,
  };
  return rat_get_normal(ret);
}

rat rat_get_sum(rat x, rat y) {
  size_t c = gcd(x.denom, y.denom);
  size_t ax = y.denom/c;
  size_t bx = x.denom/c;
  x = rat_get_extended(x, ax);              /*@\label{rat_get_extended_x}*/
  y = rat_get_extended(y, bx);
  assert(x.denom == y.denom);

  if (x.sign == y.sign) {
    x.num += y.num;
  } else if (x.num &gt y.num) {
    x.num -= y.num;
  } else {
    x.num = y.num - x.num;
    x.sign = !x.sign;
  }
  return rat_get_normal(x);
}

rat rat_get_sum2(rat x, rat y) {
  size_t c = gcd(x.denom, y.denom);
  size_t denom = (x.denom/c)*y.denom;
  size_t num;
  bool sign;

  size_t ab = x.num*(y.denom/c);
  size_t ba = y.num*(x.denom/c);
  if (x.sign == y.sign) {
      num = ab + ba;
      sign = x.sign;
  } else {
    if (ab &lt ba) {
      num = ba - ab;
      sign = y.sign;
    } else {
      num = ab - ba;
      sign = x.sign;
    }
  }
  rat ret = {
    .sign = sign,
    .num = num,
    .denom = denom,
  };
  return rat_get_normal(ret);
}

rat rat_get_prod2(rat x, rat y) {
  size_t tmp = y.denom;
  y.denom = x.denom;
  x.denom = tmp;
  x = rat_get_normal(x);
  y = rat_get_normal(y);
  rat ret = {
    .sign = (x.sign != y.sign),
    .num = x.num * y.num,
    .denom = x.denom * y.denom,
  };
  return ret;
}

void rat_destroy(rat* rp) {
  if (rp) *rp = (rat){ 0 };
}

rat* rat_init(rat* rp,
              long long num,
              unsigned long long denom) {
  if (rp) *rp = rat_get(num, denom);
  return rp;
}

rat* rat_normalize(rat* rp) {
  if (rp) *rp = rat_get_normal(*rp);
  return rp;
}

rat* rat_extend(rat* rp, size_t f) {
  if (rp) *rp = rat_get_extended(*rp, f);
  return rp;
}

rat* rat_sumup(rat* rp, rat y) {
  size_t c = gcd(rp-&gtdenom, y.denom);
  size_t ax = y.denom/c;
  size_t bx = rp-&gtdenom/c;
  rat_extend(rp, ax);              /*@\label{rat_extend_x}*/
  y = rat_get_extended(y, bx);
  assert(rp-&gtdenom == y.denom);

  if (rp-&gtsign == y.sign) {
    rp-&gtnum += y.num;
  } else if (rp-&gtnum &gt y.num) {
    rp-&gtnum -= y.num;
  } else {
    rp-&gtnum = y.num - rp-&gtnum;
    rp-&gtsign = !rp-&gtsign;
  }
  return rat_normalize(rp);       /*@\label{rat_normalize_x}*/
}

rat* rat_rma(rat* rp, rat x, rat y) {
  return rat_sumup(rp, rat_get_prod(x, y));
}

char const* rat_print(size_t len, char tmp[len], rat const* x) {
  if (x) {
    snprintf(tmp, len, "%c%zu/%zu", (x-&gtsign ? '-' : '+'), x-&gtnum, x-&gtdenom);
  } else {
    tmp[0] = 0;
  }
  return tmp;
}

#define RAT_PRINT_MAX 256

#define RAT_PRINT(X) rat_print(RAT_PRINT_MAX, (char[RAT_PRINT_MAX]){ 0 }, (rat[1]){ (X) })

int main(void) {
  rat third = rat_get(1, 3);
  rat forth = rat_get(-1, 4);
  printf("%s, prod is %s, 3x %s\n",
         RAT_PRINT(third),
         RAT_PRINT(rat_get_prod(third, third)),
         RAT_PRINT(rat_get_prod(third, rat_get_prod(third, third)))
         );
  printf("%s, prod is %s, 3x %s\n",
         RAT_PRINT(forth),
         RAT_PRINT(rat_get_prod(forth, forth)),
         RAT_PRINT(rat_get_prod(forth, rat_get_prod(forth, forth)))
         );
  printf("%s, prod is %s, 3x %s\n",
         RAT_PRINT(forth),
         RAT_PRINT(rat_get_prod(third, forth)),
         RAT_PRINT(rat_get_prod(forth, rat_get_prod(third, forth)))
         );
  printf("%s, prod is %s, 3x %s\n",
         RAT_PRINT(third),
         RAT_PRINT(rat_get_prod2(third, third)),
         RAT_PRINT(rat_get_prod2(third, rat_get_prod2(third, third)))
         );
  printf("%s, prod is %s, 3x %s\n",
         RAT_PRINT(forth),
         RAT_PRINT(rat_get_prod2(forth, forth)),
         RAT_PRINT(rat_get_prod2(forth, rat_get_prod2(forth, forth)))
         );
  printf("%s, prod is %s, 3x %s\n",
         RAT_PRINT(forth),
         RAT_PRINT(rat_get_prod2(third, forth)),
         RAT_PRINT(rat_get_prod2(forth, rat_get_prod2(third, forth)))
         );
  printf("%s, sum is %s, 3x %s\n",
         RAT_PRINT(third),
         RAT_PRINT(rat_get_sum(third, third)),
         RAT_PRINT(rat_get_sum(third, rat_get_sum(third, third)))
         );
  printf("%s, sum is %s, 3x %s\n",
         RAT_PRINT(forth),
         RAT_PRINT(rat_get_sum(forth, forth)),
         RAT_PRINT(rat_get_sum(forth, rat_get_sum(forth, forth)))
         );
  printf("%s, sum is %s, 3x %s\n",
         RAT_PRINT(forth),
         RAT_PRINT(rat_get_sum(third, forth)),
         RAT_PRINT(rat_get_sum(forth, rat_get_sum(third, forth)))
         );
  printf("%s, sum is %s, 3x %s\n",
         RAT_PRINT(third),
         RAT_PRINT(rat_get_sum2(third, third)),
         RAT_PRINT(rat_get_sum2(third, rat_get_sum2(third, third)))
         );
  printf("%s, sum is %s, 3x %s\n",
         RAT_PRINT(forth),
         RAT_PRINT(rat_get_sum2(forth, forth)),
         RAT_PRINT(rat_get_sum2(forth, rat_get_sum2(forth, forth)))
         );
  printf("%s, sum is %s, 3x %s\n",
         RAT_PRINT(forth),
         RAT_PRINT(rat_get_sum2(third, forth)),
         RAT_PRINT(rat_get_sum2(forth, rat_get_sum2(third, forth)))
         );
}
#include&ltstdio.h&gt

unsigned add(unsigned* x, unsigned const* y) {
  return *x += *y;
}
int main(void) {
  unsigned a = 3;
  unsigned b = 5; 
  printf("a = %u, b = %u\n", add(&a, &b), add(&b, &a));
}
void squareIt(double* p) {
  *p *= *p;
}
int main(void) {
  double x = 35.0; /*@\label{line:decl-x}*/
  double* xp = &x; /*@\label{line:decl-xp}*/
  {
    squareIt(&x);  /* Refers to double x *//*@\label{line:use-x-1}*/
    /*@...*/
    int x = 0;     /* Shadow double x *//*@\label{line:decl-x-2}*/
    /*@...*/
    squareIt(xp);  /* Valid use of double x *//*@\label{line:use-xp}*/
    /*@...*/
  }                /*@\label{line:end-x-2}*/
  /*@...*/
  squareIt(&x);    /* Refers to double x *//*@\label{line:use-x-2}*/
  /*@...*/
}
#include &ltsignal.h&gt
#include &lterrno.h&gt
#include &ltstdlib.h&gt
#include &ltstring.h&gt
#include "sighandler.h"

#define SH_PAIR(X, D) [X] = { .name = #X, .desc = "" D "", }

/**
 ** @brief Array that holds names and descriptions of the
 ** standard C signals
 **
 ** Conditionally, we also add some commonly used signals.
 **/
sh_pair const sh_pairs[] = {
  /* Execution errors */
  SH_PAIR(SIGFPE, "erroneous arithmetic operation"),
  SH_PAIR(SIGILL, "invalid instruction"),
  SH_PAIR(SIGSEGV, "invalid access to storage"),
#ifdef SIGBUS
  SH_PAIR(SIGBUS, "bad address"),
#endif
  /* Job control */
  SH_PAIR(SIGABRT, "abnormal termination"),
  SH_PAIR(SIGINT, "interactive attention signal"),
  SH_PAIR(SIGTERM, "termination request"),
#ifdef SIGKILL
  SH_PAIR(SIGKILL, "kill signal"),
#endif
#ifdef SIGQUIT
  SH_PAIR(SIGQUIT, "keyboard quit"),
#endif
#ifdef SIGSTOP
  SH_PAIR(SIGSTOP, "stop process"),
#endif
#ifdef SIGCONT
  SH_PAIR(SIGCONT, "continue if stopped"),
#endif
#ifdef SIGINFO
  SH_PAIR(SIGINFO, "status information request"),
#endif
};

size_t const sh_known = (sizeof sh_pairs/sizeof sh_pairs[0]);

#if ATOMIC_LONG_LOCK_FREE &gt 1
_Atomic(unsigned long) sh_counts[sizeof sh_pairs/sizeof sh_pairs[0]];
# define SH_COU " (%lu times),"
#else
# define SH_COU "%0.0lu,"
#endif

void sh_count(int);
unsigned long sh_counted(int);

#define SH_HEAD "\r%s:%zu: "
#define SH_DOC "\t%s,\t%s"


void sh_print(FILE* io, int sig,
              char const* filename, size_t line,
              char const* string) {
  char const* doc =
    (sig &lt sh_known && sh_pairs[sig].name)
    ? sh_pairs[sig].desc
    : "unknown signal number";
  if (errno) {
    char const* err = strerror(errno);
    errno = 0;
    if (!sig)
      fprintf(io, SH_HEAD "\t%s:\t%s\n", filename, line,
              string, err);
    else if (sig &lt sh_known && sh_pairs[sig].name)
      fprintf(io, SH_HEAD "%s" SH_COU SH_DOC ":\t%s\n", filename, line,
              sh_pairs[sig].name, sh_counted(sig), doc, string, err);
    else
      fprintf(io, SH_HEAD "#%d" SH_COU SH_DOC ":\t%s\n", filename, line,
              sig, sh_counted(sig), doc, string, err);
  } else {
    if (!sig)
      fprintf(io, SH_HEAD "\t%s\n", filename, line,
              string);
    else if (sig &lt sh_known && sh_pairs[sig].name)
      fprintf(io, SH_HEAD "%s" SH_COU SH_DOC "\n", filename, line,
              sh_pairs[sig].name, sh_counted(sig), doc, string);
    else
      fprintf(io, SH_HEAD "#%d" SH_COU SH_DOC "\n", filename, line,
              sig, sh_counted(sig), doc, string);
  }
}

/**
 ** @ brief Enables a signal handler and catches the errors
 **/
sh_handler* sh_enable(int sig, sh_handler* hnd) {
  sh_handler* ret = signal(sig, hnd);
  if (ret == SIG_ERR) {
    SH_PRINT(stderr, sig, "failed");
    errno = 0;
  } else if (ret == SIG_IGN) {
    SH_PRINT(stderr, sig, "previously ignored");
  } else if (ret && ret != SIG_DFL) {
    SH_PRINT(stderr, sig, "previously set otherwise");
  } else {
      SH_PRINT(stderr, sig, "ok");
  }
  return ret;
}
#include &ltsignal.h&gt
#include &lterrno.h&gt
#include &ltstdlib.h&gt
#include &ltstring.h&gt
#include "sighandler.h"

#ifndef SIGNALS
#define SIGNALS sh_known
#endif

/**
 ** @brief A simple signal handler mechanism.
 **
 ** This just raises a flag when a signal is caught.
 **
 ** All real processing of the signal has to be done
 ** in an event loop.
 **/
static sig_atomic_t volatile received;

static void signal_handler(int sig) {
  received = sig;
  switch (sig) {
#ifdef SIGQUIT
  case SIGQUIT: exit(EXIT_FAILURE);
#endif
  case SIGTERM: quick_exit(EXIT_FAILURE);
  case SIGABRT: _Exit(EXIT_FAILURE);
  default:
    /* reset the handling to its default */
    signal(sig, SIG_DFL);
    return;
  case SIGINT:  return;
  }
}

static
void signal_atexit(void) {
  SH_PRINT(stderr, received, "atexit handler");
}

static
void signal_at_quick_exit(void) {
  SH_PRINT(stderr, received, "at_quick_exit handler");
}

int main(int argc, char* argv[argc+1]) {
  atexit(signal_atexit);
  at_quick_exit(signal_at_quick_exit);
  for (unsigned i = 1; i &lt SIGNALS; ++i)
    sh_enable(i, signal_handler);
  SH_PRINT(stderr, SIGNALS-1, "highest known signal number");

  size_t const Gi = (1ull&lt&lt30);
  for(size_t step = 0; step &lt 10*Gi; ++step) {
    if (!(step%Gi)) printf("step %zu\n", step);
    switch (received) {
    case SIGINT:
      fprintf(stderr, "\ryou called?\n");
      received = 0;
    case 0:
      continue;
    }
    SH_PRINT(stderr, received, "is somebody trying to kill us?");
    raise(received);
    break;
  }
  SH_PRINT(stderr, received, "we survived");
  return EXIT_SUCCESS;
}
#include "stats.h"

void stats_collect(stats* c, double val, unsigned moments);
void stats_collect0(stats* c, double val);
void stats_collect1(stats* c, double val);
void stats_collect2(stats* c, double val);
void stats_collect3(stats* c, double val);
double stats_samples(stats* c);
double stats_mean(stats* c);
double stats_var(stats* c);
double stats_sdev(stats* c);
double stats_rsdev(stats* c);
double stats_skew(stats* c);
double stats_var_unbiased(stats* c);
double stats_sdev_unbiased(stats* c);
double stats_rsdev_unbiased(stats* c);
#include &ltstring.h&gt
#include &ltstdio.h&gt
int main(int argc, char* argv[argc+1]) {
  size_t const len = strlen(argv[0]); // Computes the length
  char name[len+1];                   // Creates a VLA
                                      // Ensures a place for 0
  memcpy(name, argv[0], len);         // Copies the name
  name[len] = 0;                      // Ensures a 0 character
  if (!strcmp(name, argv[0])) {
    printf("program name \"%s\" successfully copied\n",
           name);
  } else {
    printf("copying %s leads to different string %s\n",
           argv[0], name);
  }
}
#include &lterrno.h&gt
#include &ltlimits.h&gt
#include &ltstdbool.h&gt
#include &ltstdio.h&gt
#include &ltstdlib.h&gt
#include &ltstring.h&gt
#include &ltassert.h&gt
/* Supposes that lowercase characters are contiguous. */
static_assert('z'-'a' == 25,
               "alphabetic characters not contiguous");
#include &ltctype.h&gt
/* Converts an alphanumeric digit to an unsigned */
/* '0' ... '9'  =&gt  0 ..  9u */
/* 'A' ... 'Z'  =&gt 10 .. 35u */
/* 'a' ... 'z'  =&gt 10 .. 35u */
/* Other values =&gt   Greater */
unsigned hexatridecimal(int a) {
  if (isdigit(a)) {
    /* This is guaranteed to work: decimal digits
       are consecutive, and isdigit is not
       locale dependent. */
    return a - '0';
  } else {
    /* Leaves a unchanged if it is not lowercase */
    a = toupper(a);
    /* Returns value &gt= 36 if not Latin uppercase */
    return (isupper(a)) ? 10 + (a - 'A') : -1;
  }
}

unsigned long Strtoul_inner(char const s[static 1],
                            size_t i,
                            unsigned base) {
  unsigned long ret = 0;
  while (s[i]) {
    unsigned c = hexatridecimal(s[i]);
    if (c &gt= base) break;
    /* Maximal representable value for 64 bit is
       3w5e11264sgsf in base 36 */
    if (ULONG_MAX/base &lt ret) {
      ret = ULONG_MAX;
      errno = ERANGE;
      break;
    }
    ret *= base;
    ret += c;
    ++i;
  }
  return ret;
}

unsigned find_prefix(char const s[static 1], size_t i, char const t[static 1]) {
  size_t ret = 0;
  while (s[i+ret] && (tolower(s[i+ret]) == tolower(t[ret]))) {
    ++ret;
  }
  return ret;
}

unsigned long Strtoul(char const s[static 1], unsigned base) {
  if (base &gt 36u) {             /* Tests if base          */
    errno = EINVAL;             /* Extends the specification */
    return ULONG_MAX;
  }
  size_t i = strspn(s, " \f\n\r\t\v"); /* Skips spaces    */
  bool switchsign = false;      /* Looks for a sign       */
  switch (s[i]) {
  case '-' : switchsign = true;
  case '+' : ++i;
  }
  if (!base || base == 16) {    /* Adjusts the base       */
    size_t adj = find_prefix(s, i, "0x");
    if (!base) base =  (unsigned[]){ 10, 8, 16, }[adj];
    i += adj;
  }
  /* Now, starts the real conversion */
  unsigned long ret = Strtoul_inner(s, i, base);
  return (switchsign) ? -ret : ret;
}

char* char36(unsigned long n, unsigned base, char buf[static 256]) {
  if (base &gt 36) {
    strcpy(buf, "EINVAL");
  } else {
    unsigned i = 256;
    while (n) {
      --i;
      buf[i] = n % base;
      n /= base;
      if (buf[i] &lt 10) {
        buf[i] += '0';
      } else {
        buf[i] += 'a' - 10;
      }
    }
    memmove(buf, &buf[i], 256-i);
  }
  return buf;
}

int main(int argc, char* argv[argc+1]) {
  static unsigned const code[] = { 0, 8, 10, 16, 36, 37, };
  for (unsigned j = 0; j &lt sizeof code/ sizeof code[0]; ++j) {
    printf("%u:", code[j]);
    for (int i = 1; i &lt argc; ++i) {
      unsigned long res = Strtoul(argv[i], code[j]);
      if (res == ULONG_MAX && errno) {
        puts("");
        fprintf(stderr, "invalid conversion with base %u and \"%s\"\n", code[j], argv[i]);
        perror("error");
        errno = 0;
      } else {
        printf("\t%lu", res);
      }
    }
    puts("");
    if (code[j]) printf("%u:\tULONG_MAX %s\n", code[j], char36(ULONG_MAX, code[j], (char[256]){ 0 }));
  }
  return EXIT_SUCCESS;
}
#include &ltstdio.h&gt

/* delay execution with some crude code,
   should use thrd_sleep, once we have that */
void delay(double secs) {
  double const magic = 4E8;  // works just on my machine
  unsigned long long const nano = secs * magic;
  for (unsigned long volatile count = 0;
       count &lt nano;
       ++count) {
    /* nothing here */
  }
}

int main(int argc, char* argv[argc+1]) {
  fputs("waiting 10 seconds for you to stop me", stdout);
  if (argc &lt 3) fflush(stdout);
  for (unsigned i = 0; i &lt 10; ++i) {
    fputc('.', stdout);
    if (argc &lt 2) fflush(stdout);
    delay(1.0);
  }
  fputs("\n", stdout);
  fputs("You did ignore me, so bye bye\n", stdout);
}
#include "termin.h"
#include &lttermios.h&gt
#include &ltstdio.h&gt
#include &ltstdlib.h&gt
#include &ltstdbool.h&gt
#ifndef __STDC_NO_THREADS__
# include &ltthreads.h&gt
#endif
#include &ltctype.h&gt
#include &ltstring.h&gt

/* Store the flags as they were set before termin_unbuffered. */
static tcflag_t termin_echo;

/* The flags that we manipulate. */
#define TERMIN_FLAGS (ECHO | ECHONL | ICANON)

void termin_reset(void) {
  struct termios term;
  tcgetattr(0, &term);
  term.c_lflag |= termin_echo;
  tcsetattr(0, TCSAFLUSH, &term);
}

void termin_unbuffered(void) {
  // have stdin unbuffered on stdio level
  setvbuf(stdin, 0, _IONBF, 0);
  // store the terminal settings with respect to the flags
  struct termios term;
  tcgetattr(0, &term);
  termin_echo = term.c_lflag & TERMIN_FLAGS;
  // install exit handlers
  atexit(termin_reset);
  at_quick_exit(termin_reset);
  // change the terminal settings to raw mode
  term.c_lflag &= ~TERMIN_FLAGS;
  tcsetattr(0, TCSAFLUSH, &term);
}

static unsigned minc = 0;
static unsigned maxc = UCHAR_MAX;

static
void term_init(void) {
  while (!termin_trans[minc]) ++minc;
  while (!termin_trans[maxc]) --maxc;
}

#ifndef __STDC_NO_THREADS__
static once_flag term_once = ONCE_FLAG_INIT;
#endif

static
bool termin_read_csi(size_t len, char command[len]) {
  for (char *p = command, *stop = command+len-1; p &lt stop; ++p) {
    int c = getchar();
    // catch all: EOF, 0, control characters
    if (c &lt ' ') return false;
    p[0] = c;
    if ('@' &lt= c && c &lt= '~') {
      p[1] = 0;
      return true;
    }
  }
  return false;
}

char const* termin_read_esc(size_t len, char command[len]) {
  command[1] = getchar();
  switch (command[1]) {
  case '[':
    return
      termin_read_csi(len-2, command+2)
      ? command
      : 0;
  case 'N':
  case 'O':
  case 'Z':
  case '%':
    command[2] = getchar();
    command[3] = 0;
    return command;
  default:
    ungetc(command[1], stdin);
    return 0;
  }
}

char termin_translate(char const* command) {
  call_once(&term_once, term_init);
  for (unsigned c = minc; c &lt= maxc; ++c) {
    if (termin_trans[c] && !strcmp(command, termin_trans[c])) {
      return c;
    }
  }
  return 0;
}
#include &lttime.h&gt
#include &ltstdlib.h&gt
#include &ltstdio.h&gt
#include &ltmath.h&gt
#include "p99_constraint.h"

/*
   terran multiplicative factors between units that are fixed for
   Lunar, Day, Hour, Minute, Second
*/
enum { dl = 28, hd = 24, mh = 60, sm = 60, sh = mh*sm, sd = hd * mh * sm, };

/*
  There is a long term period of 128 years, that has exactly 31 leap
  years. This amounts to 46751 days.
*/
enum { dy = 365, yp = 128, dp = yp*dy + 31, };

/*
   Then, periods of four years are grouped together, that have either
   0 or 1 leap year.
*/
enum { yq = 4, dq0 = yq*dy, dq1 = dq0 + 1, };

time_t isotime(char const t[static 1]) {
  struct tm date[1] = {
    [0] = { .tm_year = 1900,.tm_mon = 1, },
  };
  int retscan = sscanf(t, "%i-%i-%i %i:%i:%i",
                       &date-&gttm_year, &date-&gttm_mon, &date-&gttm_mday,
                       &date-&gttm_hour, &date-&gttm_min, &date-&gttm_sec);
  if (retscan &lt= 0) {
    if (errno) perror("can't scan");
    return 0;
  }
  date-&gttm_year -= 1900;
  date-&gttm_mon -= 1;
  return mktime(date);
  /* gmtime_s(&ret, date); */
  /* return mktime(date); */
}

void time2terran(time_t t) {
  /* Provide us with the terran epoch. This is not as easy as it may
     appear as a first site, since it is difficult to express a UTC
     timestamp in a struct tm: we have convert back and forth with
     mktime and gmtime to obtain the correct timestamp at 1969-12-22 0:0:0.
   */
  struct tm terranEpoch[1] = {
    {
      .tm_year = 69, // year starts at 1900
      .tm_mon = 11,  // mon starts at 0
      .tm_mday = 23, // mday starts at 1
    },
  };
  time_t epoch = mktime(terranEpoch);
  struct tm terranEpoch2[1];
  gmtime_s(&epoch, terranEpoch2);
  time_t epoch2 = mktime(terranEpoch2);
  terranEpoch[0].tm_sec += difftime(epoch2, epoch);
  epoch = mktime(terranEpoch);

  /* Now that we have the appropriate epoch, look how many seconds
     have passed since then.
  */
  long secs = difftime(t, epoch);
  long days = secs/sd;
  secs -= days*sd;

  /*
    adjust with respect to the 128 year periods
   */
  long per = days / dp;
  if (days &lt 0) {
    per -= 1;
  }
  long year = per * yp;
  days -= per*dp;

  // the first four years aren't leap years
  if (days &lt dq0) {
    year += (days / dy);
    days -= (days / dy) * dy;
  } else {
    // correct for the first 4 years
    year += yq;
    days -= dq0;
    /*
       In the remaining period every fourth year starting with year 0
       is a leap year. Compute the amount of such 4 year periods and
       adjust
    */
    long const qer = days / dq1;
    year += qer*yq;
    days %= dq1;
    // the first year is a leap year
    if (days &gt dy+1) {
      // adjust for that leap year
      year += 1;
      days -= (dy+1);
      // compute the remaining days
      year += (days / dy);
      days %= dy;
    }
  }
  size_t const lunar = days / dl;
  days %= dl;
  while (secs &lt 0) secs += sd;
  size_t hour = secs / sh;
  secs -= hour*sh;
  size_t min = secs / sm;
  secs %= sm;
  printf("%ld.%ld.%ld,%ld:%ld:%ld TC\n", year, lunar, days, hour, min, secs);
}

int main (int argc, char* argv[argc+1]) {
  time_t now = time(0);
  time2terran(now);
  for (int i = 1; i &lt argc; ++i)
    time2terran(isotime(argv[i]));
  return EXIT_SUCCESS;
}
#include &ltstdlib.h&gt
#include "circular.h"

int main(int argc, char* argv[]) {
  size_t len = argc &gt 1 ? strtoull(argv[1], 0, 0) : 10;
  fprintf(stderr, "starting with %zu elements in total\n", len);
  circular* c = circular_new(len);
  circular_fput(c, stderr);
  for (size_t i = 0; i &lt len-1; ++i) {
    if (!circular_append(c, i)) break;
  }
  circular_fput(c, stderr);
  for (size_t i = 0; i &lt len/2; ++i) {
    if (!circular_append(c, circular_pop(c))) break;
  }
  circular_fput(c, stderr);
  circular_resize(c, 2*len);
  circular_fput(c, stderr);
  circular_resize(c, len);
  circular_fput(c, stderr);
  circular_delete(c);
}
#include "tgstring.h"
#include &ltstdio.h&gt

#define putws(S) do { printf("%ls\n", S); } while(0)

int main(void) {
  char const carray[] = "some characters";
  // this should produce a diagnostic
  char * capnc = strchr(carray, 'c');
  capnc = memchr(carray, 'c', sizeof carray);
  // this shouldn't produce a diagnostic
  char const* capc = strchr(carray, 't');
  capc = memchr(carray, 't', sizeof carray);
  printf("%s | %s\n", capnc, capc);
  // this shouldn't produce a diagnostic
  char cannc[] = "90 first text";
  char* cnextnc = memchr(cannc, 't', sizeof cannc);
  printf("reading value %lu, followed by", strtoul(cannc, &cnextnc)); puts(cnextnc);
  printf("reading value %g, followed by", strtod(cannc, &cnextnc)); puts(cnextnc);
  // this shouldn't produce a diagnostic
  char const canc[] = "11 second text";
  char const* cnextc = memchr(canc, 't', sizeof canc);
  printf("reading value %jd, followed by", strtoimax(canc, &cnextc)); puts(cnextc);
  printf("reading value %Lg, followed by", strtold(canc, &cnextc)); puts(cnextc);
  printf("reading value %lu, followed by", strtoul(cannc, &cnextc)); puts(cnextc);
  printf("reading value %g, followed by", strtod(cannc, &cnextc)); puts(cnextc);
  // these two should produce diagnostics
  printf("reading value %ju, followed by", strtoumax(canc, &cnextnc)); puts(cnextnc);
  printf("reading value %Lg, followed by", strtold(canc, &cnextnc)); puts(cnextnc);
  wchar_t const warray[] = L"some wide characters";
  // this should produce a diagnostic
  wchar_t * wapnc = strchr(warray, L'c');
  wapnc = wmemchr(warray, L'c', sizeof warray/sizeof warray[0]);
  // this shouldn't produce a diagnostic
  wchar_t const* wapc = strchr(warray, L't');
  wapc = wmemchr(warray, L't', sizeof warray/sizeof warray[0]);
  printf("%ls | %ls\n", wapnc, wapc);
  // this shouldn't produce a diagnostic
  wchar_t wcnnc[] = L"5 first text";
  wchar_t* wnextnc = 0;
  printf("reading value %lu, followed by", wcstoul(wcnnc, &wnextnc, 0)); putws(wnextnc);
  printf("reading value %g, followed by", wcstod(wcnnc, &wnextnc)); putws(wnextnc);
  // this shouldn't produce a diagnostic
  wchar_t const wcnc[] = L"37 second text";
  wchar_t const* wnextc = 0;
  printf("reading value %jd, followed by", strtoimax(wcnc, &wnextc)); putws(wnextc);
  printf("reading value %Lg, followed by", strtold(wcnc, &wnextc)); putws(wnextc);
  printf("reading value %lu, followed by", strtoul(wcnnc, &wnextc)); putws(wnextc);
  printf("reading value %g, followed by", strtod(wcnnc, &wnextc)); putws(wnextc);
  // these two should produce diagnostics
  printf("reading value %ju, followed by", strtoumax(wcnc, &wnextnc)); putws(wnextnc);
  printf("reading value %Lg, followed by", strtold(wcnc, &wnextnc)); putws(wnextnc);
}
#include &ltstdint.h&gt
#include &ltstdio.h&gt
#include &ltstdlib.h&gt
#include &ltstddef.h&gt
#include &lttime.h&gt
#include &lttgmath.h&gt

#include "stats.h"

/**
 ** @brief compute a time difference
 **
 ** This uses a @c double to compute the time. If we want to
 ** be able to track times without further loss of precision
 ** and have @c double with 52 bit mantissa, this
 ** corresponds to a maximal time difference of about 4.5E6
 ** seconds, or 52 days.
 **
 **/
double timespec_diff(struct timespec const* later,
                     struct timespec const* sooner){
  /* Be careful: tv_sec could be an unsigned type */
  if (later-&gttv_sec &lt sooner-&gttv_sec)
    return -timespec_diff(sooner, later);
  else
    return
      (later-&gttv_sec - sooner-&gttv_sec)
      /* tv_nsec is known to be a signed type. */
      + (later-&gttv_nsec - sooner-&gttv_nsec) * 1E-9;
}

uint64_t volatile s;

int main(int argc, char* argv[argc+1]) {
  if (argc &lt 2) {
    fprintf(stderr, "Usage: %s NNN, NNN iterations\n",
            argv[0]);
    return EXIT_FAILURE;
  }
  enum { probes = 10, loops = 7, };
  uint64_t iterations = strtoull(argv[1], 0, 0);
  uint64_t upper = iterations*iterations;

  stats statistic[loops] = { 0 };

  struct timespec tdummy;
  stats sdummy[4] = { 0 };

  for (unsigned probe = 0; probe &lt probes; ++probe) {
    uint64_t accu0 = 0;
    uint64_t accu1 = 0;
    struct timespec t[loops+1] = { 0 };
    timespec_get(&t[0], TIME_UTC);
    /* Volatile for i ensures that the loop is effected */
    for (uint64_t volatile i = 0; i &lt iterations; ++i) {
      /* do nothing */
    }
    timespec_get(&t[1], TIME_UTC);
    /* s must be volatile to ensure that the loop is effected */
    for (uint64_t i = 0; i &lt iterations; ++i) {
      s = i;
    }
    timespec_get(&t[2], TIME_UTC);
    /* Opaque computation ensures that the loop is effected */
    for (uint64_t i = 1; accu0 &lt upper; i += 2) {
      accu0 += i;
    }
    timespec_get(&t[3], TIME_UTC);
    /* A function call can usually not be optimized out. */
    for (uint64_t i = 0; i &lt iterations; ++i) {/*@\label{ln:accumulate}*/
      timespec_get(&tdummy, TIME_UTC);
      accu1 += tdummy.tv_nsec;
    }
    timespec_get(&t[4], TIME_UTC);
    /* A function call can usually not be optimized out, but
       an inline function can. */
    for (uint64_t i = 0; i &lt iterations; ++i) {/*@\label{ln:collect1}*/
      timespec_get(&tdummy, TIME_UTC);
      stats_collect1(&sdummy[1], tdummy.tv_nsec);
    }
    timespec_get(&t[5], TIME_UTC);
    for (uint64_t i = 0; i &lt iterations; ++i) {/*@\label{ln:collect2}*/
      timespec_get(&tdummy, TIME_UTC);
      stats_collect2(&sdummy[2], tdummy.tv_nsec);
    }
    timespec_get(&t[6], TIME_UTC);
    for (uint64_t i = 0; i &lt iterations; ++i) {/*@\label{ln:collect3}*/
      timespec_get(&tdummy, TIME_UTC);
      stats_collect3(&sdummy[3], tdummy.tv_nsec);
    }
    timespec_get(&t[7], TIME_UTC);
    /* make sure to use values of volatiles after the loop */
    printf("s, %zu iterations, accu0 %zx, accu1 %zx\n", s, accu0, accu1);
    for (size_t moment = 1; moment &lt 4; ++moment) {
      double mean = stats_mean(&sdummy[moment]);
      double sdev  = stats_rsdev_unbiased(&sdummy[moment]);
      double skew  = stats_skew(&sdummy[moment]);
      printf("%zu moments: average value of nsec\t%5.4g\tÂ± %g%% (%g skew)\n",
             moment, mean, 100.0*sdev, skew);
    }

    for (unsigned i = 0; i &lt loops; i++) {
      double diff = timespec_diff(&t[i+1], &t[i]);
      stats_collect2(&statistic[i], diff);
    }

  }

  for (unsigned i = 0; i &lt loops; i++) {
    double mean = stats_mean(&statistic[i]);
    double rsdev  = stats_rsdev_unbiased(&statistic[i]);
    printf("loop %u: E(t) (sec):\t%5.2e Â± %4.02f%%,\tloop body %5.2e\n",
           i, mean, 100.0*rsdev, mean/iterations);
  }


  return EXIT_SUCCESS;
}
#include "trampoline.h"

#define _GNU_SOURCE
#include &ltsignal.h&gt
#include &ltstdio.h&gt
#include &ltstdint.h&gt
#include &ltstdbool.h&gt
#include &ltstdlib.h&gt
#include &ltstdatomic.h&gt
#include &ltucontext.h&gt
#include &ltstring.h&gt

#ifdef __x86_64__
# define TRAMP_IP REG_RIP
# define TRAMP_SP REG_RSP
#else
# define TRAMP_IP REG_EIP
# define TRAMP_SP REG_ESP
#endif

static FILE* trp_debug = 0;
static trampoline_type** trp_table = 0;
static size_t* trp_size = 0;
static struct sigaction const* trp_old = 0;
static _Thread_local _Atomic(void const*) trp_data = 0;
static _Atomic(size_t) trp_act = 0;
static _Atomic(size_t) trp_max = 0;

/* Instantiation */
void* trampoline_sink(void* d);

#define TRACE(F, ...)                           \
  (trp_debug                                    \
   ? fprintf(trp_debug,                         \
             "%s:%lu:\t" F "\n",                \
             __func__, __LINE__+0UL,            \
             __VA_ARGS__)                       \
   : 0)

void const* trampoline_context(void* x) {
  return atomic_exchange(&trp_data, x);
}


void trampoline_reserve(size_t n) {
  trp_max += n;
}

size_t trampoline_index(_Atomic(size_t)* loc, trampoline_type* f, size_t s) {
  size_t val = 0;
  TRACE("starting: %p, %zu, %zu", (void*)f, *loc, val);
  if (atomic_compare_exchange_strong(loc, &val, SIZE_MAX)) {
    val = ++trp_act;
    *loc = val;
    trp_table[val] = f;
    trp_size[val] = s;
    TRACE("we are first: %zu", val);
  } else {
    // busy loop
    while(val == SIZE_MAX)
      val = *loc;
    if (trp_table[val] != f || trp_size[val] != s)
      raise(SIGILL);
    TRACE("we came late: %zu", val);
  }
  return val;
}

static
int sigprint(int signo, siginfo_t *si, ucontext_t* context) {
  char const* sp = context-&gtuc_stack.ss_sp;
  size_t size = context-&gtuc_stack.ss_size;
  bool si_onStack = (sp &lt= (char*)si-&gtsi_addr) && ((char*)si-&gtsi_addr &lt sp+size);
  char const* SP = (char const*)context-&gtuc_mcontext.gregs[TRAMP_SP];
  bool SP_onStack = (sp &lt= SP) && (SP &lt sp+size);
  return
    TRACE("signal %d, (%d, %d), address %p", signo, si-&gtsi_signo, si-&gtsi_code, si-&gtsi_addr)
    + TRACE("IP is %#llx", (unsigned long long){ context-&gtuc_mcontext.gregs[TRAMP_IP] })
    + TRACE("SP is %#llx", (unsigned long long){ context-&gtuc_mcontext.gregs[TRAMP_SP] })
    + TRACE("stack is located %p -&gt %p", sp, sp+size)
    + TRACE("si_addr is %s stack", (si_onStack ? "on" : "outside"))
    + TRACE("SP is %s stack", (SP_onStack ? "on" : "outside"));
}

#define SIGPRINT(NO, SI, CO) (trp_debug ? sigprint(NO, SI, CO) : 0)

static
void sighandler_report(int signo, siginfo_t *si, void* c) {
  sigaction(signo, (struct sigaction[1]){ [0] = *trp_old, }, 0);
  fputs("severe error during trampoline setup", stderr);
  ucontext_t* context = c;
  SIGPRINT(signo, si, context);
}

#define ACTION ((struct sigaction){                                     \
   .sa_sigaction = sighandler,                                          \
   .sa_flags = SA_ONSTACK | SA_SIGINFO | SA_RESTART | SA_RESETHAND,     \
   })

static
void sighandler(int signo, siginfo_t *si, void* c) {
  ucontext_t* context = c;
  SIGPRINT(signo, si, context);
  size_t* idxp = si-&gtsi_addr;
  TRACE("trampoline index %zu", *idxp);
  if (context-&gtuc_mcontext.gregs[TRAMP_IP] == (greg_t)si-&gtsi_addr) {
    /* We know now that we faulted because rip was not
       accessible. Check if this is one of the validated contexts. */
    TRACE("trampoline found %p", idxp);
    if (si-&gtsi_code == SEGV_ACCERR) {
      if (idxp && *idxp &lt= trp_act) {
        TRACE("trampoline index %zu, %p", *idxp, *(int**)(idxp+1));
        trp_data = idxp;
        /* change the instruction pointer to the function that we
           found, reestablish the signal handler for future use and
           return to the fault. This should now execute our desired
           function. */
        context-&gtuc_mcontext.gregs[TRAMP_IP] = (greg_t)trp_table[*idxp];
        SIGPRINT(signo, si, context);
        sigaction(signo, &ACTION, 0);
      } else {
        TRACE("trampoline %p is invalid", idxp);
      }
    } else {
      TRACE("trampoline %p is not mapped?", idxp);
    }
    TRACE("trampoline %p, returing", idxp);
    return;
  } else {
    /* This is not an fault of calling the pointer. Try to invoke the
       previous signal handler if possible. Otherwise the default
       handler kicks in. */
    if (trp_old) {
        if (trp_old-&gtsa_sigaction && (trp_old-&gtsa_flags&SA_SIGINFO)) {
          if (trp_debug) fputs("calling previous sigaction", trp_debug);
          trp_old-&gtsa_sigaction(signo, si, c);
        } else if (trp_old-&gtsa_handler) {
          if (trp_debug) fputs("calling previous handler", trp_debug);
          trp_old-&gtsa_handler(signo);
        }
    } else {
      char volatile* addr = si-&gtsi_addr;
      /* Reproduce the same access fault for exactly the same
         address. Now the default handler should kick in. It may e.g
         repair the fault by mapping a new page at the address. */
      TRACE("trampoline reissue fault at %p without establishing a handler", addr);
      (void)addr[0];
    }
  }
  /* If we survived all this reestablish our handler and return. At
     the original point of failure this shouldn't fault anymore. */
  sigaction(signo, &ACTION, 0);
}

static
void trp_stop(void) {
  TRACE("stopping %zu registered trampoline%s",
                   trp_act,
                   trp_act == 1 ? "" : "s");
  if (trp_old) {
    TRACE("reestablish previous handler, %p", trp_old);
    sigaction(SIGSEGV, (struct sigaction[1]){ [0] = *trp_old, }, 0);
    free((void*)trp_old);
  } else {
    TRACE("%s", "switching back to default handler");
    signal(SIGSEGV, SIG_DFL);
  }
  free(trp_table);
  free(trp_size);
}

__attribute__((constructor(1002)))
static
void trp_start(void) {
  atexit(trp_stop);
#ifdef DEBUG
  trp_debug = stderr;
#endif
  stack_t prev;
  /* If there is not yet an alternative signal stack, create it. */
  sigaltstack(0, &prev);
  if (!prev.ss_sp) {
    enum { trampoline_stksz = 10*SIGSTKSZ, };
    static
      char trampoline_stk[trampoline_stksz] = { 0 };

    stack_t alt = {
      .ss_sp = &trampoline_stk[0],
      .ss_size = 10*SIGSTKSZ,
    };
    sigaltstack(&alt, 0);
  }
  TRACE("max trampoline: %zu",  trp_max);
  trp_table = calloc(trp_max, sizeof *trp_table);
  trp_size = calloc(trp_max, sizeof *trp_size);
  struct sigaction* ttrp_old = malloc(sizeof *ttrp_old);
  sigaction(SIGSEGV, &ACTION, ttrp_old);
  if (ttrp_old-&gtsa_sigaction || ttrp_old-&gtsa_sigaction)
    trp_old = ttrp_old;
  else
    free((void*)ttrp_old);
  TRACE("trp_old handler: %p",  trp_old);
}

/* Just some small test code. */

TRAMPOLINE_DECLARE({
    int val;
    double vol;
  })
(int, fun, val, vol)
(void);

TRAMPOLINE_DEFINE(int, fun, void) ({
    TRACE("val %d, vol %g", TRAM(val), TRAM(vol));
    TRAM(vol) += 1;
    return TRAM(val);
})

TRAMPOLINE_DECLARE({
    int val;
    double vol;
  })
(int, fin, val, vol)
(void);

TRAMPOLINE_DEFINE(int, fin, void) ({
    TRACE("val %d, vol %g", TRAM(val), TRAM(vol));
    return TRAM(val);
})

int main(int argc,char ** argv)
{
  enum { early = 1, sec = 2, crash = 4 };
  unsigned long cntrl = (argc &gt 1 ? strtoul(argv[1], 0, 0) : 0);
  if (cntrl & early) return 0;
  int val = 67;
  double vol = 55;
  __typeof__(fun)* fan = TRAMPOLINE_POINTER(fun, val, vol);
  printf("%d\n", fan());
  val = 34;
  if (!(cntrl & sec))
    printf("%d\n", TRAMPOLINE_POINTER(fun, val, vol)());
  else
    printf("%d\n", TRAMPOLINE_POINTER(fin, val, vol)());
  printf("%d\n", fan());
  /* This should segfault normally because there is no defined
     context. */
  if (cntrl & crash) printf("%d\n", fun());
  return 0;
}
#include &ltstdarg.h&gt
#include &ltstddef.h&gt
#include &ltstdio.h&gt
#include &ltstdlib.h&gt

/**
 ** @brief A small, useless function to show how variadic
 ** functions work
 **/
double sumIt(size_t n, ...) {
  double ret = 0.0;
  va_list va;
  va_start(va, n);
  for (size_t i = 0; i &lt n; ++i)
    ret += va_arg(va, double);
  va_end(va);
  return ret;
}

FILE* iodebug = 0;

/**
 ** @brief Prints to the debug stream @c iodebug
 **/
#ifdef __GNUC__
__attribute__((format(printf, 1, 2)))
#endif
int printf_debug(const char *format, ...) {
  int ret = 0;
  if (iodebug) {
    va_list va;
    va_start(va, format);
    ret = vfprintf(iodebug, format, va);
    va_end(va);
  }
  return ret;
}



int main(int argc, char* argv[argc+1]) {
  if (argc &lt 4) return EXIT_FAILURE;
  iodebug = stderr;
  printf_debug("%g\n", sumIt(3, strtod(argv[1], 0), strtod(argv[2], 0), strtod(argv[3], 0)));
  return EXIT_SUCCESS;
}
#include &ltstdatomic.h&gt

/**
 ** @brief A simple accumulation in a loop
 **
 ** Any decent optimizer should be able to figure out that the return
 ** value is @c 100 and that the only side effect is to store the
 ** value @c 10 into @c *count.
 **/
unsigned accu(unsigned*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  (*count) = 0;
  while (tmp &lt 9) {
    tmp = (*count)++;
    ret += 2*tmp +1;
  }
  return ret;
}

/**
 ** @brief @c volatile qualification
 **
 ** @c volatile forces all stores to be effected. So this has side
 ** effects of storing @f$0, \ldots, 10@f$ into @c *count.
 **/
unsigned accuv(unsigned volatile*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  (*count) = 0;
  while (tmp &lt 9) {
    tmp = (*count)++;
    ret += 2*tmp +1;
  }
  return ret;
}

/**
 ** @brief @c _Atomic specification
 **
 ** Here, because it is not @c volatile, none of the side effects
 ** would have to be made visible before returning. Only there is an
 ** ambiguous phrase in the C standard:
 **
 ** &ltquote&gt
 ** Atomic read-modify-write operations shall always read the last
 ** value (in the modification order) stored before the write
 ** associated with the read-modify-write operation.
 ** &lt/quote&gt
 **
 ** This can be read that for read-modify-write operations the read
 ** and write operations *must* be effected.
 **/
unsigned accua(_Atomic(unsigned)*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  (*count) = 0;
  while (tmp &lt 9) {
    tmp = (*count)++;
    ret += 2*tmp +1;
  }
  return ret;
}

unsigned accuav(_Atomic(unsigned) volatile*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  (*count) = 0;
  while (tmp &lt 9) {
    tmp = (*count)++;
    ret += 2*tmp +1;
  }
  return ret;
}

unsigned accuar(_Atomic(unsigned)*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  atomic_store_explicit(count, 0, memory_order_relaxed);
  while (tmp &lt 9) {
    tmp = atomic_fetch_add_explicit(count, 1u, memory_order_relaxed);
    ret += 2*tmp +1;
  }
  return ret;
}

unsigned accuavr(_Atomic(unsigned) volatile*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  atomic_store_explicit(count, 0, memory_order_relaxed);
  while (tmp &lt 9) {
    tmp = atomic_fetch_add_explicit(count, 1u, memory_order_relaxed);
    ret += 2*tmp +1;
  }
  return ret;
}

unsigned accut(unsigned*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  (*count) = 0;
  while (tmp &lt 10) {
    ret += 2*tmp +1;
    (*count) = ++tmp;
  }
  return ret;
}

unsigned accutv(unsigned volatile*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  (*count) = 0;
  while (tmp &lt 10) {
    ret += 2*tmp +1;
    (*count) = ++tmp;
  }
  return ret;
}

unsigned accuta(_Atomic(unsigned)*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  (*count) = 0;
  while (tmp &lt 10) {
    ret += 2*tmp +1;
    (*count) = ++tmp;
  }
  return ret;
}

unsigned accutav(_Atomic(unsigned) volatile*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  (*count) = 0;
  while (tmp &lt 10) {
    ret += 2*tmp +1;
    (*count) = ++tmp;
  }
  return ret;
}

unsigned accutar(_Atomic(unsigned)*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  atomic_store_explicit(count, 0, memory_order_relaxed);
  while (tmp &lt 10) {
    ret += 2*tmp +1;
    atomic_store_explicit(count, ++tmp, memory_order_relaxed);
  }
  return ret;
}

unsigned accutavr(_Atomic(unsigned) volatile*restrict count) {
  unsigned ret = 0;
  unsigned tmp = 0;
  atomic_store_explicit(count, 0, memory_order_relaxed);
  while (tmp &lt 10) {
    ret += 2*tmp +1;
    atomic_store_explicit(count, ++tmp, memory_order_relaxed);
  }
  return ret;
}
#include &lttime.h&gt
#include &ltstdbool.h&gt
#include &ltstdio.h&gt

bool leapyear(unsigned year) {
  /* All years that are divisible by 4 are leap years,
     unless they start a new century, provided they
     are not divisible by 400. */
  return !(year % 4) && ((year % 100) || !(year % 400));
}

#define DAYS_BEFORE                             \
(int const[12]){                                \
  [0] = 0, [1] = 31, [2] = 59, [3] = 90,        \
  [4] = 120, [5] = 151, [6] = 181, [7] = 212,   \
  [8] = 243, [9] = 273, [10] = 304, [11] = 334, \
}

struct tm time_set_yday(struct tm t) {
  // tm_mdays starts at 1.
  t.tm_yday += DAYS_BEFORE[t.tm_mon] + t.tm_mday - 1;
  // Takes care of leap years
  if ((t.tm_mon &gt 1) && leapyear(t.tm_year+1900))
    ++t.tm_yday;
  return t;
}

int main(void) {
  struct tm today = {
    .tm_year = 2019-1900,
    .tm_mon  = 4-1,
    .tm_mday = 3,
    .tm_hour = 10,
    .tm_min  = 0,
    .tm_sec  = 47,
  };
  printf("this year is %d, next year will be %d\n",
         today.tm_year+1900, today.tm_year+1900+1);
  today = time_set_yday(today);
  printf("day of the year is %d\n", today.tm_yday);
}
#ifndef CIRCULAR_H
# define CIRCULAR_H 1

# include &ltstddef.h&gt
# include &ltstdio.h&gt

/** @brief an opaque type for a circular buffer for @c double values
 **
 ** This data structure allows to add @c double values in rear and to
 ** take them out in front. Each such structure has a maximal amount
 ** of elements that can be stored in it.
 **
 **/
typedef struct circular circular;

/**
 ** @name Initialization and destruction
 ** @{
 **/

/** @brief Initialize a circular buffer @a c with maximally @a
 ** max_len elements.
 **
 ** Only use this function on an uninitialized buffer.
 **
 ** Each buffer that is initialized with this function must be
 ** destroyed with a call to ::circular_destroy.
 **/
circular* circular_init(circular* c, size_t max_len);

/** @brief Destroy circular buffer @a c
 **
 ** @a c must have been initialized with a call to ::circular_init
 **/
void circular_destroy(circular* c);

/** @brief Allocate and initialize a circular buffer with maximally
 ** @a len elements.
 **
 ** Each buffer that is allocated with this function must be deleted
 ** with a call to ::circular_delete.
 **/
circular* circular_new(size_t len);

/** @brief Delete circular buffer @a c
 **
 ** @a c must have been allocated with a call to ::circular_new
 **/
void circular_delete(circular* c);
/**
 ** @}
 **/

/**
 ** @name Using elements of a circular
 ** @{
 **/

/** @brief Append a new element with value @a value to the buffer @a c
 **
 ** @return c if the new element could be appended, @c 0 otherwise.
 **/
circular* circular_append(circular* c, double value);

/** @brief Remove the oldest element from @a c and return its value
 **
 ** @return the removed element if it exists, @c 0.0 otherwise.
 **/

double circular_pop(circular* c);

/** @brief Return a pointer to position @a pos in buffer @a c
 **
 ** @return a pointer to element @a pos of the buffer, @c 0 otherwise.
 **/
double* circular_element(circular* c, size_t pos);


/**
 ** @}
 **/

/**
 ** @name Maintain a circular
 ** @{
 **/

/** @brief Return the number of elements stored. */
size_t circular_getlength(circular* c);

/** @brief Resize to capacity @a max_len. */
circular* circular_resize(circular* c, size_t max_len);

/** @brief Print the buffer values to stream @a s. */
void circular_fput(circular* c, FILE* s);

/**
 ** @}
 **/



#endif
#ifndef CRASH_H
#define CRASH_H 1

/**
 ** @brief enable alignment check for i386 processors
 **
 ** Intel's i386 processor family is quite tolerant in accepting
 ** misalignment of data. This can lead to irritating bugs when ported
 ** to other architectures that are not as tolerant.
 **
 ** This function enables a check for this problem also for this
 ** family or processors, such that you can be sure to detect this
 ** problem early.
 **
 ** I found that code on Ygdrasil's blog:
 ** http://orchistro.tistory.com/206
 **/

inline
void enable_alignment_check(void) {
#if defined(__GNUC__)
# if defined(__x86_64__)
  __asm__("pushf\n"
          "\torl $0x40000, (%%rsp)\n"
          "\tpopf"
          : : : "cc");
# elif defined(__i386__)
  __asm__("pushf\n"
          "\torl $0x40000, (%%esp)\n"
          "\tpopf"
          : : : "cc");
# endif
#endif
}


#endif
#ifndef ESCAPE_H
#define ESCAPE_H 1

#include &ltstdio.h&gt

#define ESC_CSI     "\e["
#define ESC_SS2     "\eN"
#define ESC_SS3     "\eO"
#define ESC_SCI     "\eZ"
#define ESC_ROI     "\e%"

#define ESC_SAVE    ESC_CSI "s"
#define ESC_RESTORE ESC_CSI "u"
#define ESC_HOME    ESC_CSI "H"
#define ESC_CLRSCR  ESC_CSI "1J"
#define ESC_CLEAR   ESC_CSI "2K"
#define ESC_UP      ESC_CSI "A"
#define ESC_DOWN    ESC_CSI "B"
#define ESC_FRWD    ESC_CSI "C"
#define ESC_BKWD    ESC_CSI "D"
#define ESC_END     ESC_CSI "F"
#define ESC_INSERT  ESC_CSI "2~"
#define ESC_DELETE  ESC_CSI "3~"
#define ESC_PGUP    ESC_CSI "5~"
#define ESC_PGDOWN  ESC_CSI "6~"

// F1 to F4 are special
#define ESC_F1      ESC_SS3 "P"
#define ESC_F2      ESC_SS3 "Q"
#define ESC_F3      ESC_SS3 "R"
#define ESC_F4      ESC_SS3 "S"
#define ESC_S_F1    ESC_CSI "1;2P"
#define ESC_S_F2    ESC_CSI "1;2Q"
#define ESC_S_F3    ESC_CSI "1;2R"
#define ESC_S_F4    ESC_CSI "1;2S"
#define ESC_C_F1    ESC_CSI "1;5P"
#define ESC_C_F2    ESC_CSI "1;5Q"
#define ESC_C_F3    ESC_CSI "1;5R"
#define ESC_C_F4    ESC_CSI "1;5S"

#define ESC_F5      ESC_CSI "15~"
#define ESC_F6      ESC_CSI "17~"
#define ESC_F7      ESC_CSI "18~"
#define ESC_F8      ESC_CSI "19~"
#define ESC_F9      ESC_CSI "20~"
#define ESC_F10     ESC_CSI "21~"
#define ESC_F11     ESC_CSI "23~"
#define ESC_F12     ESC_CSI "24~"

#define ESC_S_F5    ESC_CSI "15;2~"
#define ESC_S_F6    ESC_CSI "17;2~"
#define ESC_S_F7    ESC_CSI "18;2~"
#define ESC_S_F8    ESC_CSI "19;2~"
#define ESC_S_F9    ESC_CSI "20;2~"
#define ESC_S_F10   ESC_CSI "21;2~"
#define ESC_S_F11   ESC_CSI "23;2~"
#define ESC_S_F12   ESC_CSI "24;2~"

#define ESC_C_F5    ESC_CSI "15;5~"
#define ESC_C_F6    ESC_CSI "17;5~"
#define ESC_C_F7    ESC_CSI "18;5~"
#define ESC_C_F8    ESC_CSI "19;5~"
#define ESC_C_F9    ESC_CSI "20;5~"
#define ESC_C_F10   ESC_CSI "21;5~"
#define ESC_C_F11   ESC_CSI "23;5~"
#define ESC_C_F12   ESC_CSI "24;5~"

#define ESC_HIDE    ESC_CSI "?25l"
#define ESC_SHOW    ESC_CSI "?25h"

#define ESC_NORMAL  ESC_CSI "0m"
#define ESC_BOLD    ESC_CSI "1m"
#define ESC_UNDERL  ESC_CSI "4m"
#define ESC_BLINK   ESC_CSI "5m"
#define ESC_INVERS  ESC_CSI "7m"
#define ESC_FRAMED  ESC_CSI "51m"
#define ESC_CIRCLED ESC_CSI "52m"
#define ESC_OVERL   ESC_CSI "53m"

#define ESC_TBLACK  ESC_CSI "30m"
#define ESC_TRED    ESC_CSI "38;2;255;0;0m"
#define ESC_TGREEN  ESC_CSI "38;2;0;255;0m"
#define ESC_TYELLOW ESC_CSI "38;2;255;255;0m"
#define ESC_TBLUE   ESC_CSI "38;2;0;0;255m"
#define ESC_TMAGENTA ESC_CSI "38;2;255;0;255m"
#define ESC_TCYAN   ESC_CSI "38;2;0;255;255m"
#define ESC_TWHITE  ESC_CSI "37m"

#define ESC_BBLACK  ESC_CSI "40m"
#define ESC_BRED    ESC_CSI "48;2;255;0;0m"
#define ESC_BGREEN  ESC_CSI "48;2;0;255;0m"
#define ESC_BYELLOW ESC_CSI "48;2;255;255;0m"
#define ESC_BBLUE   ESC_CSI "48;2;0;0;255m"
#define ESC_BMAGENTA ESC_CSI "48;2;255;0;255m"
#define ESC_BCYAN   ESC_CSI "48;2;0;255;255m"
#define ESC_BWHITE  ESC_CSI "47m"

#define ESC_BLIGHTGREY ESC_CSI "48;2;220;220;220m"
#define ESC_BGREY      ESC_CSI "48;2;128;128;128m"


enum { esc_top = 1, esc_bottom = 2, esc_left = 4, esc_right = 8, };

#define ESC_BORDER                                      \
((char const*const[]){                                  \
[0] = " ",                                              \
  [esc_top] = "â",                                      \
  [esc_bottom] = "â",                                   \
  [esc_bottom | esc_top] = "â",                         \
  [esc_left] = "â",                                     \
  [esc_left | esc_top] = "â",                           \
  [esc_left | esc_bottom] = "â",                        \
  [esc_left | esc_bottom | esc_top] = "â£",              \
  [esc_right] = "â",                                    \
  [esc_right | esc_top] = "â",                          \
  [esc_right | esc_bottom] = "â",                       \
  [esc_right | esc_bottom | esc_top] = "â«",             \
  [esc_right | esc_left] = "â",                         \
  [esc_right | esc_left | esc_top] = "â³",               \
  [esc_right | esc_left | esc_bottom] = "â»",            \
  [esc_right | esc_left | esc_bottom | esc_top] = "â",  \
  })

enum { esc_nw = 1, esc_ne = 2, esc_sw = 4, esc_se = 8, };

#define ESC_BLOCK                               \
((char const*const[]){                          \
[0] = " ",                                      \
  [esc_nw] = "â",                               \
  [esc_ne] = "â",                               \
  [esc_ne | esc_nw] = "â",                      \
  [esc_sw] = "â",                               \
  [esc_sw | esc_nw] = "â",                      \
  [esc_sw | esc_ne] = "â",                      \
  [esc_sw | esc_ne | esc_nw] = "â",             \
  [esc_se] = "â",                               \
  [esc_se | esc_nw] = "â",                      \
  [esc_se | esc_ne] = "â",                      \
  [esc_se | esc_ne | esc_nw] = "â",             \
  [esc_se | esc_sw] = "â",                      \
  [esc_se | esc_sw | esc_nw] = "â",             \
  [esc_se | esc_sw | esc_ne] = "â",             \
  [esc_se | esc_sw | esc_ne | esc_nw] = "â",    \
  })

/**
 ** @brief relative cursor movement
 **/
void esc_move(FILE* f, int vert, int hori);

/**
 ** @brief asolute cursor movement
 **/
void esc_goto(FILE* f, unsigned vert, unsigned hori);

#endif
#ifndef EUCLID_H
# define EUCLID_H 1

# include &ltstdlib.h&gt
# include &ltstdio.h&gt
# include &ltassert.h&gt

size_t gcd2(size_t a, size_t b) {
  assert(a &lt= b);                 /*@\label{gcd2-precondition}*/
  if (!a) return b;               /*@\label{gcd2-bottom}*/
  size_t rem = b % a;             /*@\label{gcd2-remainder}*/
  return gcd2(rem, a);            /*@\label{gcd2-recurse}*/
}

size_t gcd(size_t a, size_t b) {
  assert(a);
  assert(b);
  if (a &lt b)
    return gcd2(a, b);
  else
    return gcd2(b, a);
}

#endif
#ifndef GENERIC_H
#define GENERIC_H 1
#include &ltstdbool.h&gt
#include &ltlimits.h&gt
#include &ltfloat.h&gt

inline
double min(double a, double b) {
  return a &lt b ? a : b;
}

inline
long double minl(long double a, long double b) {
  return a &lt b ? a : b;
}

inline
float minf(float a, float b) {
  return a &lt b ? a : b;
}

/**
 ** @brief Type-generic minimum for floating-point values
 **/
#define min(A, B)                               \
_Generic((A)+(B),                               \
         float: minf,                           \
         long double: minl,                     \
         default: min)((A), (B))

/**
 ** @brief The maximum value for the type of @a X
 **/
#define MAXVAL(X)                                       \
_Generic((X),                                           \
         bool: (bool)+1,                                \
         char: (char)+CHAR_MAX,                         \
         signed char: (signed char)+SCHAR_MAX,          \
         unsigned char: (unsigned char)+UCHAR_MAX,      \
         signed short: (signed short)+SHRT_MAX,         \
         unsigned short: (unsigned short)+USHRT_MAX,    \
         signed: INT_MAX,                               \
         unsigned: UINT_MAX,                            \
         signed long: LONG_MAX,                         \
         unsigned long: ULONG_MAX,                      \
         signed long long: LLONG_MAX,                   \
         unsigned long long: ULLONG_MAX,                \
         float: FLT_MAX,                                \
         double: DBL_MAX,                               \
         long double: LDBL_MAX)

/**
 ** @brief The maximum promoted value for @a XT, where XT
 ** can be an expression or a type name
 **
 ** So this is the maximum value when fed to an arithmetic
 ** operation such as @c +.
 **
 ** @remark Narrow types are promoted, usually to @c signed,
 ** or maybe to @c unsigned on rare architectures.
 **/
#define maxof(XT)                               \
_Generic(0+(XT)+0,                              \
         signed: INT_MAX,                       \
         unsigned: UINT_MAX,                    \
         signed long: LONG_MAX,                 \
         unsigned long: ULONG_MAX,              \
         signed long long: LLONG_MAX,           \
         unsigned long long: ULLONG_MAX,        \
         float: FLT_MAX,                        \
         double: DBL_MAX,                       \
         long double: LDBL_MAX)

#define MINVAL(X)                               \
_Generic((X),                                   \
         bool: (bool)+0,                        \
         char: (char)+CHAR_MIN,                 \
         signed char: (signed char)+SCHAR_MIN,  \
         unsigned char: (unsigned char)+0,      \
         signed short: (signed short)+SHRT_MIN, \
         unsigned short: (unsigned short)+0,    \
         signed: INT_MIN,                       \
         unsigned: 0U,                          \
         signed long: LONG_MIN,                 \
         unsigned long: 0UL,                    \
         signed long long: LLONG_MIN,           \
         unsigned long long: 0ULL,              \
         float: -FLT_MAX,                       \
         double: -DBL_MAX,                      \
         long double: -LDBL_MAX)

#define minof(XT)                               \
_Generic(0+(XT)+0,                              \
         signed: INT_MIN,                       \
         unsigned: 0U,                          \
         signed long: LONG_MIN,                 \
         unsigned long: 0UL,                    \
         signed long long: LLONG_MIN,           \
         unsigned long long: 0ULL,              \
         float: -FLT_MAX,                       \
         double: -DBL_MAX,                      \
         long double: -LDBL_MAX)

/**
 ** @brief Calls a two-parameter function with default arguments set to
 ** 0
 **/
#define ZERO_DEFAULT2(...) ZERO_DEFAULT2_0(__VA_ARGS__, 0, )
#define ZERO_DEFAULT2_0(FUNC, _0, _1, ...) FUNC(_0, _1)

#define strtod(...) ZERO_DEFAULT2(strtod, __VA_ARGS__)
#define strtof(...) ZERO_DEFAULT2(strtof, __VA_ARGS__)
#define strtold(...) ZERO_DEFAULT2(strtold, __VA_ARGS__)

/**
 ** @brief Calls a three-parameter function with default arguments
 ** set to 0
 **/
#define ZERO_DEFAULT3(...) ZERO_DEFAULT3_0(__VA_ARGS__, 0, 0, )
#define ZERO_DEFAULT3_0(FUNC, _0, _1, _2, ...) FUNC(_0, _1, _2)

#define strtoul(...) ZERO_DEFAULT3(strtoul, __VA_ARGS__)
#define strtoull(...) ZERO_DEFAULT3(strtoull, __VA_ARGS__)
#define strtol(...) ZERO_DEFAULT3(strtol, __VA_ARGS__)
#define strtoll(...) ZERO_DEFAULT3(strtoll, __VA_ARGS__)

typedef struct placeholder placeholder;
#define PLH ((placeholder*)0)

/**
 ** @brief Default value for the second argument of @c strtoXX
 ** functions
 **/
#define STRTO2ND(X) _Generic((X), placeholder*: 0, default: (X))

/**
 ** @brief Default value for the third argument of @c strtoXX
 ** functions
 **/
#define STRTO3RD(X) _Generic((X), placeholder*: 10, default: (X))

/**
 ** @brief Calls a three-parameter function with default arguments set to
 ** specific values
 **
 ** @see strtoull10 for an example
 **/
#define DEFAULT3(...) DEFAULT3_0(__VA_ARGS__, PLH, PLH, PLH)
#define DEFAULT3_0(FUNC, DEF1, DEF2, _0, _1, _2, ...) FUNC(_0, DEF1(_1), DEF2(_2))

#define strtoul10(...) DEFAULT3(strtoul, STRTO2ND, STRTO3RD, __VA_ARGS__)
#define strtoull10(...) DEFAULT3(strtoull, STRTO2ND, STRTO3RD, __VA_ARGS__)
#define strtol10(...) DEFAULT3(strtol, STRTO2ND, STRTO3RD, __VA_ARGS__)
#define strtoll10(...) DEFAULT3(strtoll, STRTO2ND, STRTO3RD, __VA_ARGS__)

#define PROMOTE(XT, A)                                  \
  _Generic(0+(XT)+0,                                    \
           signed: (signed)(A),                         \
           unsigned: (unsigned)(A),                     \
           signed long: (signed long)(A),               \
           unsigned long: (unsigned long)(A),           \
           signed long long: (signed long long)(A),     \
           unsigned long long: (unsigned long long)(A), \
           float: (float)(A),                           \
           double: (double)(A),                         \
           long double: (long double)(A))

#define SIGNEDNESS(XT) (PROMOTE(XT, -1) &lt PROMOTE(XT, 0))

inline
signed maxs(signed a, signed b) {
  return a &lt b ? b : a;
}

inline
unsigned maxu(unsigned a, unsigned b) {
  return a &lt b ? b : a;
}

inline
unsigned maxus(unsigned a, signed b) {
  return b &lt 0 ? a : maxu(a, b);
}

inline
unsigned maxsu(signed a, unsigned b) {
  return a &lt 0 ? b : maxu(a, b);
}

inline
signed long maxsl(signed long a, signed long b) {
  return a &lt b ? b : a;
}

inline
unsigned long maxul(unsigned long a, unsigned long b) {
  return a &lt b ? b : a;
}

inline
unsigned long maxusl(unsigned long a, signed long b) {
  return b &lt 0 ? a : maxul(a, b);
}

inline
unsigned long maxsul(signed long a, unsigned long b) {
  return a &lt 0 ? b : maxul(a, b);
}

inline
signed long long maxsll(signed long long a, signed long long b) {
  return a &lt b ? b : a;
}

inline
unsigned long long maxull(unsigned long long a, unsigned long long b) {
  return a &lt b ? b : a;
}

inline
unsigned long long maxusll(unsigned long long a, signed long long b) {
  return b &lt 0 ? a : maxull(a, b);
}

inline
unsigned long long maxsull(signed long long a, unsigned long long b) {
  return a &lt 0 ? b : maxull(a, b);
}

#define  MAX(X, Y)                              \
_Generic((X)+(Y),                               \
         signed: maxs,                          \
         unsigned: maxu,                        \
         signed long: maxsl,                    \
         unsigned long: maxul,                  \
         signed long long: maxsll,              \
         unsigned long long: maxull)((X), (Y))

#define MAXUS(X, Y)                             \
_Generic((X)+(Y),                               \
         signed: maxus,                         \
         unsigned: maxus,                       \
         signed long: maxusl,                   \
         unsigned long: maxusl,                 \
         signed long long: maxusll,             \
         unsigned long long: maxusll)((X), (Y))

#define MAXSU(X, Y)                             \
_Generic((X)+(Y),                               \
         signed: maxsu,                         \
         unsigned: maxsu,                       \
         signed long: maxsul,                   \
         unsigned long: maxsul,                 \
         signed long long: maxsull,             \
         unsigned long long: maxsull)((X), (Y))

#define mix(X, Y)                                       \
_Generic(&(char[SIGNEDNESS(X)-SIGNEDNESS(Y)+2]){ 0 },   \
         char(*)[1]: MAXUS((X), (Y)),                   \
         char(*)[2]: MAX((X), (Y)),                     \
         char(*)[3]: MAXSU((X), (Y)))


#endif
#ifndef HERON_K_H
#define HERON_K_H 1

#include &ltstdlib.h&gt
#include &ltstdio.h&gt
/* Math functions usually need "-lm" as compiler argument: */
#include &ltmath.h&gt
#include &ltassert.h&gt
#include &ltfloat.h&gt


/**
 ** @file
 ** @brief Implement a Heron process to approximate powers of `1/k`
 **/


/**
 ** @def FLT_RDXRDX
 ** @brief the radix base 2 of @c FLT_RADIX
 **
 ** This is needed internally for some of the code below.
 **/
#if FLT_RADIX == 2
# define FLT_RDXRDX 1
#elif FLT_RADIX == 4
# define FLT_RDXRDX 2
#elif FLT_RADIX == 8
# define FLT_RDXRDX 3
#elif FLT_RADIX == 16
# define FLT_RDXRDX 4
#else
# error "encoutered platform with unusual FLT_RADIX, please report"
/**
 ** @def FLT_RDXRDX
 ** @brief the radix base 2 of @c FLT_RADIX
 **
 ** This is needed internally for some of the code below.
 **/
# define FLT_RDXRDX something
#endif

/**
 ** @brief raise @a to the power of @a k
 **
 ** @warning manual implementation as an exercise, never use in
 ** production code
 **
 ** @pre @a k must be a power of 2.0
 **/
double expk2(double a, unsigned k);

/**
 ** @brief raise @a to the power of @a k
 **
 ** @warning manual implementation as an exercise, never use in
 ** production code
 **
 ** @pre @a a must be strictly greater than 0.
 **/
double expk_rec(double a, unsigned k);

/**
 ** @brief convert floating-point number to fractional and integral components
 **
 ** @warning manual implementation as an exercise, never use in
 ** production code
 **
 ** This implementation just repeatedly multiplies the input value by
 ** 2.0 or 0.5.
 **/
double frexp_np(double x, signed exp[static 1]);

/**
 ** @brief compute a good estimate for the Heron process for k=-1
 ** @return x is a power of 2 such that 0.5 &lt= x*a &lt 1.0
 ** @pre Supposes that a &gt 0
 **/
double heron1_estimate(double a);

/**
 ** @brief compute a good estimate for the Heron process for k=-1
 ** @return x is a power of 2 such that 0.5 &lt= x*a &lt 1.0
 ** @pre Supposes that 0 &lt a &lt 0.5
 **/
double heron1_estimate_dir_05(double a);

/**
 ** @brief compute a good estimate for the Heron process for k=-1
 ** @return x is a power of 2 such that 0.5 &lt= x*a &lt 1.0
 ** @pre Supposes that a &gt 1.0
 **/
double heron1_estimate_dir_10(double a);

/**
 ** @brief compute a good estimate for the Heron process for k=-1
 ** @return x is a power of 2 such that 0.5 &lt= x*a &lt 1.0
 ** @pre Supposes that a &gt 0.0
 **/
double heron1_estimate_dir(double a);

/**
 ** @brief use the Heron process to approximate 1.0/a
 ** @pre Supposes that a &gt 0.0
 **/
double heron1(double a);

/**
 ** @brief raise @a to the power of @a k
 **
 ** @warning manual implementation as an exercise, never use in
 ** production code
 **/
double expk(double a, signed k);

/**
 ** @brief use the Heron process to approximate @a a to the
 ** power of `1/k`
 **
 ** Or in other words this computes the @f$k^{th}@f$ root of @a a.
 ** As a special feature, if @a k is `-1` it computes the
 ** multiplicative inverse of @a a.
 **
 ** @param a must be greater than `0.0`
 ** @param k should not be `0` and otherwise be between
 ** `DBL_MIN_EXP*FLT_RDXRDX` and
 ** `DBL_MAX_EXP*FLT_RDXRDX`.
 **
 ** @see FLT_RDXRDX
 **/
double heron(double a, signed k);

#endif
#include &ltstdbool.h&gt
#include &ltctype.h&gt
#ifndef __STDC_NO_THREADS__
# include &ltthreads.h&gt
#else
# error This needs C11 threads, aborting.
#endif
#include &ltstdatomic.h&gt


enum { life_maxit = 1ull &lt&lt 23, };

typedef struct life life;
struct life {
  mtx_t mtx;    //&lt Mutex that protects Mv
  cnd_t draw;   //&lt cnd that controls drawing
  cnd_t acco;   //&lt cnd that controls accounting
  cnd_t upda;   //&lt cnd that controls updating

  void*restrict Mv;            //&lt bool M[n0][n1];
  bool (*visited)[life_maxit]; //&lt Hashing constellations

  // A bunch of parameters that are not subject to change
  size_t n0;    //&lt Number of rows
  size_t n1;    //&lt Number of columns
  size_t off0;  //&lt Start row
  size_t len0;  //&lt Number of rows to be handled
  size_t off1;  //&lt Start column
  size_t len1;  //&lt Number of columns to be handled
  void* restrict Bv;  //&lt Unsigned char B[len0][len1];


  // Parameters that are updated but that are protected by the mutex
  size_t iteration;   //&lt Current iteration
  size_t accounted;   //&lt Last accounted iteration
  size_t drawn;       //&lt Last drawn iteration
  size_t last;        //&lt Last iteration with new state
  size_t birth9;      //&lt Number of birth9 calls

  // Parameters that will dynamically be changed by
  // different threads
  _Atomic(size_t) constellations; //&lt Constellations visited
  _Atomic(size_t) x0;             //&lt Cursor position, row
  _Atomic(size_t) x1;             //&lt Cursor position, column
  _Atomic(size_t) frames;         //&lt FPS for display
  _Atomic(bool)   finished;       //&lt This game is finished.
};

inline
void life_advance(life* L, signed t0, signed t1) {
  if (t0) {
    size_t n = L-&gtn0-2;
    L-&gtx0 = ((L-&gtx0-1)+n+t0)%n + 1;
  }
  if (t1) {
    size_t n = L-&gtn1-2;
    L-&gtx1 = ((L-&gtx1-1)+n+t1)%n + 1;
  }
}

int life_wait(cnd_t*, mtx_t*);
void life_sleep(double s);

void life_birth9(life*);
size_t life_update(life*restrict L);
void life_count(life*restrict L);
void life_draw(life*);
void life_draw4(life*);
void life_account(life*);
life* life_init(life*, size_t _n, size_t _m, bool[_n][_m]);
void life_destroy(life* L);
void life_torus(life*);

#define LIFE_INITIALIZER                        \
{                                               \
    .visited = 0,                               \
    .birth9 = 1,                                \
    .x0 = 1,                                    \
    .x1 = 1,                                    \
    .frames = 20,                               \
    .finished = false,                          \
    .constellations = 1,                        \
    .birth9 = 1,                                \
}
#ifndef MACRO_TRACE_H
#define MACRO_TRACE_H 1
#include &ltstdio.h&gt
#include &ltstdbool.h&gt

/**
 ** @file
 **
 ** @brief A sequence of macros for tracing execution
 **/

/**
 ** @brief A simple version of the macro that just does
 ** a @c fprintf or nothing
 **/
#if NDEBUG
# define TRACE_PRINT0(F, X) do { /* nothing */ } while (false)
#else
# define TRACE_PRINT0(F, X) fprintf(stderr, F, X)
#endif

/**
 ** @brief A simple version of the macro that ensures that the @c
 ** fprintf format is a string literal
 **
 ** As an extra, it also adds a newline to the printout, so
 ** the user doesn't have to specify it each time.
 **/
#if NDEBUG
# define TRACE_PRINT1(F, X) do { /* nothing */ } while (false)
#else
# define TRACE_PRINT1(F, X) fprintf(stderr, "" F "\n", X)
#endif

/**
 ** @brief A macro that resolves to @c 0 or @c 1 according to @c
 ** NDEBUG being set
 **/
#ifdef NDEBUG
# define TRACE_ON 0
#else
# define TRACE_ON 1
#endif

/**
 ** @brief A simple version of the macro that ensures that the @c
 ** fprintf call is always evaluated
 **/
#define TRACE_PRINT2(F, X)                                      \
do { if (TRACE_ON) fprintf(stderr, "" F "\n", X); } while (false)

/**
 ** @brief Traces a value without having to specify a format
 **/
#define TRACE_VALUE0(HEAD, X) TRACE_PRINT2(HEAD " %Lg", (X)+0.0L)

/**
 ** @brief Traces a pointer without having to specify a format
 **
 ** @warning Uses a cast of @a X to @c void*
 **/
#define TRACE_PTR0(HEAD, X)  TRACE_PRINT2(HEAD " %p", (void*)(X))

/**
 ** @brief Traces a pointer without specifying a format
 **/
#define TRACE_PTR1(HEAD, X)                     \
TRACE_PRINT2(HEAD " %p", ((void*){ 0 } = (X)))

/**
 ** @brief Adds the current line number to the trace
 **/
#define TRACE_PRINT3(F, X)                              \
do {                                                    \
  if (TRACE_ON)                                         \
    fprintf(stderr, "%lu: " F "\n", __LINE__+0UL, X);   \
} while (false)

/**
 ** @brief Adds the name of the current function to the trace
 **/
#define TRACE_PRINT4(F, X)                      \
do {                                            \
  if (TRACE_ON)                                 \
   fprintf(stderr, "%s:%lu: " F "\n",           \
           __func__, __LINE__+0UL, X);          \
} while (false)

#define STRINGIFY(X) #X
#define STRGY(X) STRINGIFY(X)
/**
 ** @brief Adds a textual version of the expression that is evaluated
 **/
#define TRACE_PRINT5(F, X)                                      \
do {                                                            \
 if (TRACE_ON)                                                  \
  fprintf(stderr, "%s:" STRGY(__LINE__) ":(" #X "): " F "\n",   \
          __func__, X);                                         \
} while (false)

/**
 ** @brief Allows multiple arguments to be printed in the
 ** same trace
 **/
#define TRACE_PRINT6(F, ...)                            \
do {                                                    \
  if (TRACE_ON)                                         \
    fprintf(stderr, "%s:" STRGY(__LINE__) ": " F "\n",  \
            __func__, __VA_ARGS__);                     \
} while (false)

/**
 ** @brief Only traces with a text message; no values printed
 **/
#define TRACE_PRINT7(...)                                     \
do {                                                          \
 if (TRACE_ON)                                                \
  fprintf(stderr, "%s:" STRGY(__LINE__) ": " __VA_ARGS__ "\n",\
          __func__);                                          \
} while (false)

/**
 ** @brief Extracts the first argument from a list of arguments
 **/
#define TRACE_FIRST(...) TRACE_FIRST0(__VA_ARGS__, 0)
#define TRACE_FIRST0(_0, ...) _0

/**
 ** @brief Removes the first argument from a list of arguments
 **
 ** @remark This is only suitable in our context,
 ** since this adds an artificial last argument.
 **/
#define TRACE_LAST(...) TRACE_LAST0(__VA_ARGS__, 0)
#define TRACE_LAST0(_0, ...) __VA_ARGS__

/**
 ** @brief Traces with or without values
 **
 ** This implementation has the particularity of adding a format
 ** @c "%.0d" to skip the last element of the list, which was
 ** artificially added.
 **/
#define TRACE_PRINT8(...)                       \
TRACE_PRINT6(TRACE_FIRST(__VA_ARGS__) "%.0d",   \
             TRACE_LAST(__VA_ARGS__))

/**
 ** @brief Traces by first giving a textual representation of the
 ** arguments
 **/
#define TRACE_PRINT9(F, ...)                            \
TRACE_PRINT6("(" #__VA_ARGS__ ") " F, __VA_ARGS__)

inline
char const* trace_skip(char const expr[static 1]){
  for (char const* p = expr+1; *p; ++p) {
    // at the end of head we expect the 3 chars ``", ''
    if (p[0] == '"') return p+3;
    // watch out for escaped " characters
    if (p[0] == '\\' && p[1] == '"') ++p;
  }
  return 0;
}

/**
 ** @brief A function to print a list of values
 **
 ** @remark Only call this through the macro ::TRACE_VALUES,
 ** which will provide the necessary contextual information.
 **/
inline
void trace_values(FILE* s,
                  char const func[static 1],
                  char const line[static 1],
                  char const expr[static 1],
                  char const head[static 1],
                  size_t len, long double const arr[len]) {
  fprintf(s, "%s:%s:(%s) %s %Lg", func, line,
          trace_skip(expr), head, arr[0]);
  for (size_t i = 1; i &lt len-1; ++i)
    fprintf(s, ", %Lg", arr[i]);
  fputc('\n', s);
}

/**
 ** @brief Returns the number of arguments in the ... list
 **
 ** This version works for lists with up to 31 elements.
 **
 ** @remark An empty argument list is taken as one (empty) argument.
 **/
#define ALEN(...) ALEN0(__VA_ARGS__,                    \
  0x1E, 0x1F, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18,       \
  0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10,       \
  0x0E, 0x0F, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08,       \
  0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00)

#define ALEN0(_00, _01, _02, _03, _04, _05, _06, _07,           \
              _08, _09, _0A, _0B, _0C, _0D, _0F, _0E,           \
              _10, _11, _12, _13, _14, _15, _16, _17,           \
              _18, _19, _1A, _1B, _1C, _1D, _1F, _1E, ...) _1E

/**
 ** @brief Traces a list of arguments without having to specify
 ** the type of each argument
 **
 ** @remark This constructs a temporary array with the arguments
 ** all converted to @c long double. Thereby implicit conversion
 ** to that type is always guaranteed.
 **/
#define TRACE_VALUES(...)                       \
TRACE_VALUES0(ALEN(__VA_ARGS__),                \
              #__VA_ARGS__,                     \
              __VA_ARGS__,                      \
              0                                 \
              )

#define TRACE_VALUES0(NARGS, EXPR, HEAD, ...)                   \
do {                                                            \
  if (TRACE_ON) {                                               \
    if (NARGS &gt 1)                                              \
      trace_values(stderr, __func__, STRGY(__LINE__),           \
                   "" EXPR "", "" HEAD "", NARGS,               \
                   (long double const[NARGS]){ __VA_ARGS__ });  \
    else                                                        \
      fprintf(stderr, "%s:" STRGY(__LINE__) ": %s\n",           \
              __func__, HEAD);                                  \
  }                                                             \
 } while (false)

/**
 ** @brief Returns a format that is suitable for @c fprintf
 **
 ** @return The argument @a F must be a string literal,
 ** so the return value will be.
 **
 **/
#define TRACE_FORMAT(F, X)                      \
_Generic((X)+0LL,                               \
         unsigned long long: "" F " %llu\n",    \
         long long: "" F " %lld\n",             \
         float: "" F " %.8f\n",                 \
         double: "" F " %.12f\n",               \
         long double: "" F " %.20Lf\n",         \
         default: "" F " %p\n")

/**
 ** @brief Returns a value that forcibly can be interpreted as
 ** pointer value
 **
 ** That is, any pointer will be returned as such, but other
 ** arithmetic values will result in a @c 0.
 **/
#define TRACE_POINTER(X)                        \
_Generic((X)+0LL,                               \
         unsigned long long: 0,                 \
         long long: 0,                          \
         float: 0,                              \
         double: 0,                             \
         long double: 0,                        \
         default: (X))

/**
 ** @brief Returns a value that is promoted either to a wide
 ** integer, to a floating point, or to a @c void* if @a X is a
 ** pointer
 **/
#define TRACE_CONVERT(X)                                \
_Generic((X)+0LL,                                       \
         unsigned long long: (X)+0LL,                   \
         long long: (X)+0LL,                            \
         float: (X)+0LL,                                \
         double: (X)+0LL,                               \
         long double: (X)+0LL,                          \
         default: ((void*){ 0 } = TRACE_POINTER(X)))

/**
 ** @brief Traces a value without having to specify a format
 **
 ** This variant works correctly with pointers.
 **
 ** The formats are tunable by changing the specifiers in
 ** ::TRACE_FORMAT.
 **/
#define TRACE_VALUE1(F, X)                                      \
  do {                                                          \
    if (TRACE_ON)                                               \
      fprintf(stderr,                                           \
              TRACE_FORMAT("%s:" STRGY(__LINE__) ": " F, X),    \
              __func__, TRACE_CONVERT(X));                      \
  } while (false)

#endif
#include &ltstdint.h&gt
#include &ltstddef.h&gt
#include &ltstdlib.h&gt
#include &ltstring.h&gt
#include &ltwchar.h&gt
#include &ltwctype.h&gt
#include &ltctype.h&gt

/**
 ** @file
 ** @brief Helper functions for multibyte strings.
 **
 ** These functions try to ease the use of multibyte strings. Most of
 ** the time they pass through wide character functions to achieve
 ** their goal. This has only use that is somewhat limited if on
 ** platform wide characters are not of fixed width but use
 ** surrogates. For such surrogate characters the classification
 ** functions will fail erratically.
 **
 ** @warning this implementations supposes that @c wchar_t supports
 ** some form of Unicode.
 **/

#ifndef __STDC_ISO_10646__
# error "wchar_t wide characters have to be Unicode code points"
#endif
#ifdef __STDC_MB_MIGHT_NEQ_WC__
# error "basic character codes must agree on char and wchar_t"
#endif

/**
 ** @brief A type for 16 bit characters as provided by "uchar.h"
 **
 ** This is the base type of strings that are prefixed with @c u, such
 ** as in &ltcode&gtu"string"&lt/code&gt.
 **
 ** There are good chances that on most platforms this is the UCS-2
 ** encoding, thus an encoding that has surrogates.
 **
 ** @remark This should be provided by the header file, but the type
 ** is fixed as is given here, and C11 compilers should tolerate a
 ** repetition of a @c typedef, as long as it is consistent.
 **/
typedef uint_least16_t char16_t;

/**
 ** @brief A type for 32 bit characters as provided by "uchar.h"
 **
 ** This is the base type of strings that are prefixed with @c U, such
 ** as in &ltcode&gtU"string"&lt/code&gt.
 **
 ** There are good chances that on most platforms this is the UCS-4
 ** encoding, thus an encoding without surrogates.
 **
 ** @remark This should be provided by the header file, but the type
 ** is fixed as is given here, and C11 compilers should tolerate a
 ** repetition of a @c typedef, as long as it is consistent.
 **/
typedef uint_least32_t char32_t;

/**
 ** @brief A helper type to ensure proper initialization of @c
 ** mbstate_t variables
 **
 ** Not to be used directly
 ** @see MBSTATE
 **/
union mbstate_t_ {
  unsigned char bytes[sizeof(mbstate_t)];
  mbstate_t state;
} mbstate_t_;

/**
 ** @brief Provide a pointer to a properly initialized @c mbstate_t
 **
 ** This uses the union type to ensure that the state is initialized
 ** with all bytes set to @c 0.
 **/
#define MBSTATE (&(union mbstate_t_){ .bytes = { 0 }}.state)

/**
 ** @brief For functions that receive a wide character classification
 ** function as an argument.
 **/
typedef int (*wcclass_t)(wint_t);

/**
 ** @brief Interpret a sequence of bytes in @a c as mb character
 ** and return that as wide character through @a C
 **
 ** @return the length of the mb character or @c -1 if an
 ** encoding error occured.
 **
 ** This function can be integrated into a sequence of such
 ** searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions.
 **
 ** @remark @a state of @c 0 indicates that @a c can be scanned
 ** without considering any context.
 **/
size_t mbrtow(wchar_t*restrict C, char const c[restrict static 1],
              mbstate_t*restrict state);

/**
 ** @brief Interpret a sequence of bytes in @a c as mb character and
 ** return that as wide character.
 **
 ** @return the wide character converted to @c wint_t or @c WEOF if an
 ** encoding error occurred.
 **
 ** This function should only be used for strings containing one
 ** single mb character. It cannot be integrated into a sequence of
 ** searches through a string with more characters since the @c
 ** mbstate_t is not kept.
 **/
wint_t mbtow(char const*c);

/**
 ** @brief Interpret a mb string in @a mbs and return its
 ** length when interpreted as a wide character string
 **
 ** @return the length of the mb string or @c -1 if an
 ** encoding error occured.
 **
 ** This function can be integrated into a sequence of searches
 ** through a string, as long as a @a state argument is passed to
 ** this function that is consistent with the mb character
 ** starting in @a mbs. The state itself is not modified by this
 ** function.
 **
 ** @remark @a state of @c 0 indicates that @a mbs can be scanned
 ** without considering any context.
 **/
size_t mbsrlen(char const*restrict mbs,
               mbstate_t const*restrict state);

/**
 ** @brief Interpret a sequence of bytes in @a s as mb string and
 ** convert it to a wide character string.
 **
 ** @return a newly malloc'ed wide character string of the
 ** appropriate length, @c 0 if an encoding error occurred.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as a @a state
 ** argument is passed to this function that is consistent with
 ** the mb character starting in @a c. The state itself is not
 ** modified by this function.
 **
 ** @remark @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
wchar_t* mbsrdup(char const*s, mbstate_t const*restrict state);

/**
 ** @brief Copy at most @a n bytes of the mb string @a s to @a t.
 **
 ** This is meant to be an efficient variant of ::mbsrncpy for
 ** the case the copy operation can be done with ::memcpy.
 **
 ** Mb string @a s is supposed to be a complete mb string in
 ** initial shift state. If it has no @c 0 character in the first
 ** @a n bytes, the copy operation fails and the function returns
 ** @c 0.
 **
 ** The mb string that is produced in @a t may be the
 ** continuation of an existing prefix who's conversion state is
 ** described by @a state.
 **
 ** If @a s can not completely be copied because the adjustment
 ** of the shift state would leave less than
 ** &ltcode&gtstrlen(s)+1&lt/code&gt space in @a t, the copy operation is
 ** aborted and @c 0 is returned.
 **
 ** @return the address of the terminating null character in @a t
 ** if the copy operation succeeded, @c 0 otherwise. In case of
 ** success, @a t is in an initial shift state for the returned
 ** position.
 **/
char* mbsrmbsncpy(size_t n, char t[restrict n], mbstate_t const*restrict state,
                  char const s [restrict static 1]);


/**
 ** @brief Copy at most @a n bytes of the mb string @a s to @a t.
 **
 ** This is a safe variant of ::mbsrmbsncpy that covers all
 ** cases.
 **
 ** Mb string @a s is supposed to be a mb string in state @a
 ** sstate. If it has no @c 0 character in the first @a n bytes,
 ** the copy operation will be partial up to that point.
 **
 ** The mb string that is produced in @a t may be the continuation of
 ** an existing prefix who's conversion state is described by @a
 ** sstate.
 **
 ** This function copies complete mb characters as long as they
 ** fit into the target array. To be able to do so, the
 ** conversion state of @a t might have to be adapted to be in
 ** sync with @a s. By that the copied part may be longer than
 ** &ltcode&gtstrlen(s)+1&lt/code&gt.
 **
 ** @return The address of the first byte in @a t after the copy
 ** is returned; that byte is null if the whole @a s could be
 ** copied. If nothing could be copied, @a t is returned. In that
 ** case @c *t is not written to and @a tstate is unchanged.
 **/
char* mbsrncpy(size_t n, char t[restrict n], mbstate_t*restrict tstate,
               char const s [restrict static 1], mbstate_t const*restrict sstate);


/**
 ** @brief Interpret a sequence of bytes in @a s as mb string and
 ** search for wide character @a C
 **
 ** @return the @a occurrence'th position in @a s that starts a
 ** mb sequence corresponding to @a C or @c 0 if an encoding
 ** error occurred.
 **
 ** If the number of occurrences is less than @a occurrence the
 ** last such position is returned. So in particular using @c
 ** SIZE_MAX (or @c -1) will always return the last occurrence.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions and
 ** as long as the continuation of the search starts at the
 ** position that is returned by this function.
 **
 ** @remark @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
char const* mbsrwc(char const s[restrict static 1],
                   mbstate_t*restrict state,
                   wchar_t C, size_t occurrence);

/**
 ** @brief Interpret a sequence of bytes in @a s as mb string and
 ** search for mb character represented by @a c
 **
 ** @return the @a occurrence'th position in @a s that starts a
 ** mb sequence corresponding to @a c or @c 0 if an encoding
 ** error occurred.
 **
 ** If the number of occurrences is less than @a occurrence the
 ** last such position is returned. So in particular using @c
 ** SIZE_MAX (or @c -1) will always return the last occurrence.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions and
 ** as long as the continuation of the search starts at the
 ** position that is returned by this function.
 **
 ** @remark @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
char const* mbsrmb(char const s[static 1], mbstate_t*restrict state,
                   char const c[static 1], size_t occurence);

/**
 ** @brief Interpret a sequence of bytes in @a s as mb string and
 ** and reverse search for wide character @a C
 **
 ** @return the maximal position in @a s that starts a mb
 ** sequence corresponding to @a C or @c 0 if an encoding error
 ** occured.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions and
 ** as long as the continuation of the search starts at the
 ** position that is returned by this function.
 **
 ** @remark @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
char const* mbsrrwc(char const s[restrict static 1], mbstate_t*restrict state,
                    wchar_t C);

/**
 ** @brief Interpret a sequence of bytes in @a s as mb string and
 ** reverse search for mb character represented by @a c
 **
 ** @return the maximal position in @a s that starts a mb
 ** sequence corresponding to @a c or @c 0 if an encoding error
 ** occured.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions and
 ** as long as the continuation of the search starts at the
 ** position that is returned by this function.
 **
 ** @remark @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
char const* mbsrrmb(char const s[static 1], mbstate_t*restrict state,
                    char const c[static 1]);

/**
 ** @brief In mb string @a s1 jump over the initial segment
 ** corresponding to wide character string @a S2.
 **
 ** @return the position in @a s1 after the initial segment if @a
 ** S2 is found or @c 0 otherwise.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions and
 ** as long as the continuation of the search starts at the
 ** position that is returned by this function.
 **
 ** @remark A @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
char const* mbsrwcjump(char const s1[static 1], mbstate_t*restrict state,
                       size_t S2len, wchar_t const S2[S2len]);

/**
 ** @brief In mb string @a s1 find a segment corresponding to
 ** wide character string @a S2.
 **
 ** @return the position in @a s1 that starts the first such
 ** segment if @a S2 is found or @c 0 otherwise.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions and
 ** as long as the continuation of the search starts at the
 ** position that is returned by this function.
 **
 ** @remark A @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
char const* mbsrwcs(char const s1[static 1], mbstate_t*restrict state,
                    wchar_t const S2[static 1]);

/**
 ** @brief In mb string @a s1 find a segment corresponding to mb
 ** string @a s2.
 **
 ** @return the position in @a s1 that starts the first such
 ** segment if @a s2 is found or @c 0 otherwise.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions and
 ** as long as the continuation of the search starts at the
 ** position that is returned by this function.
 **
 ** @remark A @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
char const* mbsrmbs(char const s1[static 1], mbstate_t*restrict state,
                    char const s2[static 1]);

/**
 ** @brief In mb string @a s1 skip over the initial part of the
 ** string that corresponds to wide characters in string @a S2.
 **
 ** @return the position in @a s1 that corresponds to the the
 ** first non-matching wide character in @a S2, which may be the
 ** terminating @c 0 character or a position that produces an
 ** encoding error.
 **
 ** @a state is updated to correspond to the returned position.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions and
 ** as long as the continuation of the search starts at the
 ** position that is returned by this function.
 **
 ** @remark A @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
char const* mbsrwcsskip(char const s1[static 1], mbstate_t*restrict state,
                        wchar_t const* S2);

/**
 ** @brief In mb string @a s1 skip over the initial part of the
 ** string that corresponds to mb characters in string @a s2.
 **
 ** @return the position in @a s1 that corresponds to the the
 ** first non-matching mb character in @a s2, which may be the
 ** terminating @c 0 character or a position that produces an
 ** encoding error.
 **
 ** @a state is updated to correspond to the returned position.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions and
 ** as long as the continuation of the search starts at the
 ** position that is returned by this function.
 **
 ** @remark A @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
char const* mbsrskip(char const s1[static 1], mbstate_t*restrict state,
                     char const* s2);

/**
 ** @brief In mb string @a s1 return the length of the initial
 ** part of the string that corresponds to mb characters in
 ** string @a s2.
 **
 ** @return the position in @a s1 that corresponds to the the
 ** first non-matching mb character in @a s2, which may be the
 ** terminating @c 0 character or a position that produces an
 ** encoding error.
 **
 ** @remark This function supposes that @a s1 can be scanned
 ** without context, that is it starts in an initial shift state.
 **/
size_t mbsspn(char const* s1, char const* s2);

/**
 ** @brief In mb string @a s1 skip over the initial part of the
 ** string that verifies classification @a func.
 **
 ** @return the position in @a s1 that corresponds to the the
 ** first non-matching mb character in @a s2, which may be the
 ** terminating @c 0 character or a position that produces an
 ** encoding error.
 **
 ** @a state is updated to correspond to the returned position.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions and
 ** as long as the continuation of the search starts at the
 ** position that is returned by this function.
 **
 ** @remark A @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
char const* mbsrskip_class(char const s1[static 1], mbstate_t*restrict state,
                           wcclass_t func);

/**
 ** @brief In mb string @a s1 return the length of the initial
 ** part of the string that verifies classification @a func.
 **
 ** @return the position in @a s1 that corresponds to the the
 ** first non-matching mb character in @a s2, which may be the
 ** terminating @c 0 character or a position that produces an
 ** encoding error.
 **
 ** @remark This function supposes that @a s1 can be scanned
 ** without context, that is it starts in an initial shift state.
 **/
size_t mbsspn_class(char const* s1, wcclass_t func);

/**
 ** @brief In mb string @a s1 skip over the initial part of the
 ** string that verifies type @a type.
 **
 ** @return the position in @a s1 that corresponds to the the
 ** first non-matching mb character in @a s2, which may be the
 ** terminating @c 0 character or a position that produces an
 ** encoding error.
 **
 ** @a state is updated to correspond to the returned position.
 **
 ** @remark This function can be integrated into a sequence of
 ** such searches through a string, as long as the same @a state
 ** argument passed to all calls to this or similar functions and
 ** as long as the continuation of the search starts at the
 ** position that is returned by this function.
 **
 ** @remark A @a state of @c 0 indicates that @a s can be scanned
 ** without considering any context.
 **/
char const* mbsrskip_type(char const s1[static 1], mbstate_t*restrict state, wctype_t type);

/**
 ** @brief In mb string @a s1 return the length of the initial
 ** part of the string that verifies type @a type.
 **
 ** @return the position in @a s1 that corresponds to the the
 ** first non-matching mb character in @a s2, which may be the
 ** terminating @c 0 character or a position that produces an
 ** encoding error.
 **
 ** @remark This function supposes that @a s1 can be scanned
 ** without context, that is it starts in an initial shift state.
 **/
size_t mbsspn_type(char const* s1, wctype_t type);

/**
 ** @brief In mb string @a s1 return the length of the initial
 ** part of the string who's type corresponds to category @a
 ** name.
 **
 ** Predefined standard names are @c "alnum", @c "alpha", @c
 ** "blank", @c "cntrl", @c "digit", @c "graph", @c "lower", @c
 ** "print", @c "punct", @c "space", @c "upper", and @c
 ** "xdigit". Others may be provided by your platform.
 **
 ** @return the position in @a s1 that corresponds to the the
 ** first non-matching mb character in @a s2, which may be the
 ** terminating @c 0 character or a position that produces an
 ** encoding error.
 **
 ** @remark This function supposes that @a s1 can be scanned
 ** without context, that is it starts in an initial shift state.
 **/
size_t mbsspn_name(char const* s1, char const name[static 1]);

/**
 ** @brief In mb string @a s1 skip over the initial part of the
 ** string that doesn't correspond to wide characters in string
 ** @a S2.
 **
 ** @see mbsrwcsskip 
 **/
char const* mbsrwcscskip(char const s1[static 1], mbstate_t*restrict state, wchar_t const* S2);

/**
 ** @brief In mb string @a s1 skip over the initial part of the
 ** string that doesn't correspond to mb characters in string @a
 ** s2.
 **
 ** @see mbsrskip
 **/
char const* mbsrcskip(char const* s1, mbstate_t*restrict state, char const* s2);

/**
 ** @brief In mb string @a s1 skip over the initial part of the
 ** string that doesn't correspond to mb characters in string @a
 ** s2.
 **
 ** @see mbsrskip
 **/
size_t mbscspn(char const* s1, char const* s2);

/**
 ** @brief Convert mb string @a s1 to @c double.
 **
 ** @see strtod
 **/
double mbsrtod(char const*restrict s1, mbstate_t*restrict state, char**restrict endptr);

/**
 ** @brief Convert mb string @a s1 to &ltcode&gtlong double&lt/code&gt.
 **
 ** @see strtold
 **/
long double mbsrtold(char const*restrict s1, mbstate_t*restrict state, char**restrict endptr);

/**
 ** @brief Convert mb string @a s1 to &ltcode&gtlong&lt/code&gt according
 ** to base @a base.
 **
 ** @see strtol
 **/
long mbsrtol(char const*restrict s1, mbstate_t*restrict state, char**restrict endptr, int base);

/**
 ** @brief Convert mb string @a s1 to &ltcode&gtlong long&lt/code&gt according
 ** to base @a base.
 **
 ** @see strtoll
 **/
long long mbsrtoll(char const*restrict s1, mbstate_t*restrict state, char**restrict endptr, int base);

/**
 ** @brief Convert mb string @a s1 to &ltcode&gtunsigned long&lt/code&gt
 ** according to base @a base.
 **
 ** @see strtoul
 **/
unsigned long mbsrtoul(char const*restrict s1, mbstate_t*restrict state, char**restrict endptr, int base);

/**
 ** @brief Convert mb string @a s1 to &ltcode&gtunsigned long
 ** long&lt/code&gt according to base @a base.
 **
 ** @see strtoull
 **/
unsigned long long mbsrtoull(char const*restrict s1, mbstate_t*restrict state, char**restrict endptr, int base);

#ifndef RATIONALS_H
# define RATIONALS_H 1
# include &ltstdbool.h&gt
# include "euclid.h"

typedef struct rat rat;

struct rat {
  bool sign;
  size_t num;
  size_t denom;
};

/* Functions that return a value of type rat. */
rat rat_get(long long num, unsigned long long denom);
rat rat_get_normal(rat x);
rat rat_get_extended(rat x, size_t f);
rat rat_get_prod(rat x, rat y);
rat rat_get_sum(rat x, rat y);


/* Functions that operate on pointers to rat. */
void rat_destroy(rat* rp);
rat* rat_init(rat* rp,
              long long num,
              unsigned long long denom);
rat* rat_normalize(rat* rp);
rat* rat_extend(rat* rp, size_t f);
rat* rat_sumup(rat* rp, rat y);
rat* rat_rma(rat* rp, rat x, rat y);

/* Functions that are implemented as exercises. */
/** @brief Print @a x into @a tmp and return tmp. **/
char const* rat_print(size_t len, char tmp[len], rat const* x);
/** @brief Print @a x normalize and print. **/
char const* rat_normalize_print(size_t len, char tmp[len],
                                rat const* x);
rat* rat_dotproduct(rat rp[static 1], size_t n,
                    rat const A[n], rat const B[n]);

#endif
#ifndef SIGHANDLER_H
#define SIGHANDLER_H 1

#include &ltsignal.h&gt
#include &ltstdio.h&gt
#ifndef __STDC_NO_ATOMIC__
# include &ltstdatomic.h&gt
#endif

/**
 ** @brief A pair of strings to hold signal information
 **/
typedef struct sh_pair sh_pair;
struct sh_pair {
  char const* name;
  char const* desc;
};

/**
 ** @brief For each possible signal, this holds a pair of strings with
 ** signal information.
 **
 ** The size of this array can be queried with ::sh_known.
 **
 ** @see SH_PRINT to use that information.
 **/
extern sh_pair const sh_pairs[];

extern size_t const sh_known;

#if ATOMIC_LONG_LOCK_FREE &gt 1
/**
 ** @brief Keep track of the number of calls into a
 **  signal handler for each possible signal.
 **
 ** Don't use this array directly.
 **
 ** @see sh_count to update this information.
 ** @see SH_PRINT to use that information.
 **/
extern _Atomic(unsigned long) sh_counts[];

/**
 ** @brief Use this in your signal handler to keep track of the
 ** number of calls to the signal @a sig.
 **
 ** @see sh_counted to use that information.
 **/
inline
void sh_count(int sig) {
  if (sig &lt sh_known) ++sh_counts[sig];
}

inline
unsigned long sh_counted(int sig){
  return (sig &lt sh_known) ? sh_counts[sig] : 0;
}

#else
inline
void sh_count(int sig) {
  // empty
}

inline
unsigned long sh_counted(int sig){
  return 0;
}
#endif

/**
 ** @brief Prototype of signal handlers
 **/
typedef void sh_handler(int);

/**
 ** @brief Pretty-prints signal information
 **
 ** @see PRINT_SIG for a convenient user interface
 **/
void sh_print(FILE* io, int sig,
              char const* filename, size_t line,
              char const* string);

/**
 ** @brief Pretty-prints signal information
 **
 ** This prints signal information @a STRING for signal @a SIG to
 ** stream @a IO.
 **/
#define SH_PRINT(IO, SIG, STRING) sh_print(IO, SIG, __FILE__, __LINE__, STRING)

/**
 ** @ brief Enables a signal handler and catches the errors
 **/
sh_handler* sh_enable(int sig, sh_handler* hnd);


#endif
#include &ltstddef.h&gt
#include &lttgmath.h&gt
#include &ltstdio.h&gt

/**
 ** @file
 ** @brief Collect some simple statistics online as we go.
 **
 ** This uses a generalization of Welford's trick to compute running
 ** mean and variance. See
 **
 ** Philippe PÃ©bay. Formulas for robust, one-pass parallel computation
 ** of covariances and arbitrary-order statistical moments. Technical
 ** Report SAND2008-6212, SANDIA, 2008. URL
 ** http://prod.sandia.gov/techlib/access-control.cgi/2008/086212.pdf.
 **/
typedef struct stats stats;

/**
 ** @brief A simple data structure to collect the 0th to 3rd moment of
 ** a statistic.
 **
 ** @warning Since this also uses a @c double for the number of
 ** samples, the validity of all this is restricted to about
 ** @f$2^{50}@f$ samples.
 **/
struct stats {
  double moment[4];
};


/**
 ** @brief Return the number of samples that had been entered into the
 ** statistic @a c.
 **/
inline
double stats_samples(stats* c) {
  return c-&gtmoment[0];
}

/**
 ** @brief Return the mean value of the samples that had been entered
 ** into the statistic @a c.
 **/
inline
double stats_mean(stats* c) {
  return c-&gtmoment[1];
}

/**
 ** @brief Return the variance of the samples that had been entered
 ** into the statistic @a c.
 **/
inline
double stats_var(stats* c) {
  return c-&gtmoment[2]/stats_samples(c);
}

/**
 ** @brief Return the standard deviation of the samples that had been
 ** entered into the statistic @a c.
 **/
static inline
double stats_sdev(stats* c) {
  return sqrt(stats_var(c));
}

/**
 ** @brief Return the relative standard deviation of the samples that
 ** had been entered into the statistic @a c.
 **/
static inline
double stats_rsdev(stats* c) {
  return sqrt(stats_var(c))/stats_mean(c);
}

/**
 ** @brief Return the normalized skew of the samples that had been
 ** entered into the statistic @a c.
 **/
static inline
double stats_skew(stats* c) {
  double var = stats_var(c);
  return (c-&gtmoment[3]/pow(var, 1.5))/stats_samples(c);
}

/**
 ** @brief Return the unbiased variance of the samples that had been
 ** entered into the statistic @a c.
 **
 ** Use Bessel's correction to have an estimation of the unbiased
 ** variance of the overall population.
 **/
static inline
double stats_var_unbiased(stats* c) {
  return c-&gtmoment[2]/(stats_samples(c)-1);
}

/**
 ** @brief Return the unbiased standard deviation of the samples that
 ** had been entered into the statistic @a c.
 **
 ** Use Bessel's correction to have an less biased estimation of the
 ** variance of the overall population.
 **/
static inline
double stats_sdev_unbiased(stats* c) {
  return sqrt(stats_var_unbiased(c));
}

/**
 ** @brief Return the unbiased relative standard deviation of the
 ** samples that had been entered into the statistic @a c.
 **/
static inline
double stats_rsdev_unbiased(stats* c) {
  return stats_rsdev(c)*(1+1/(4*stats_samples(c)));
}

/**
 ** @brief Add value @a val to the statistic @a c.
 **/
inline
void stats_collect(stats* c, double val, unsigned moments) {
  double n  = stats_samples(c);
  double n0 = n-1;
  double n1 = n+1;
  double delta0 = 1;
  double delta  = val - stats_mean(c);
  double delta1 = delta/n1;
  double delta2 = delta1*delta*n;
  switch (moments) {
  default:
    c-&gtmoment[3] += (delta2*n0 - 3*c-&gtmoment[2])*delta1;
  case 2:
    c-&gtmoment[2] += delta2;
  case 1:
    c-&gtmoment[1] += delta1;
  case 0:
    c-&gtmoment[0] += delta0;
  }
}

inline
void stats_collect0(stats* c, double val) {
  stats_collect(c, val, 0);
}

inline
void stats_collect1(stats* c, double val) {
  stats_collect(c, val, 1);
}

inline
void stats_collect2(stats* c, double val) {
  stats_collect(c, val, 2);
}

inline
void stats_collect3(stats* c, double val) {
  stats_collect(c, val, 3);
}
#ifndef TERMIN_H
#define TERMIN_H 1

#include &ltlimits.h&gt
#include &ltstddef.h&gt
#include "esc.h"

/**
 ** @brief Set a terminal on stdin to raw mode.
 **
 ** This uses termios.h underneath, so it probably only works on POSIX
 ** systems.
 **
 ** The terminal is automatically reset to its original state on @c
 ** exit or @c quick_exit by means of ::termin_reset.
 **/
void termin_unbuffered(void);

/**
 ** @brief Reset the terminal to its original state.
 **/
void termin_reset(void);

/**
 ** @brief The translation table for escape sequences.
 **
 ** An application that wants to use this module has to provide this
 ** symbol.
 **
 ** @see ::termin_translate
 **/
extern char const*const termin_trans[UCHAR_MAX+1];

/**
 ** @brief Translate and escape sequence to a simple character.
 **
 ** This supposes that you assign a simple character for each escape
 ** sequence that you want to translate.
 **
 ** If an exact match for an escape sequence is fount in
 ** ::termin_trans, its position in the table is the translation.
 **
 ** @see ::termin_trans
 **/
char termin_translate(char const* command);

/**
 ** @brief Read an escape sequence into @a command.
 **
 ** This reads from @c stdin and supposes that the escape character is
 ** already stored in @c command[0].
 **/
char const* termin_read_esc(size_t len, char command[len]);

#endif
#ifndef __STDC_TGSTRING__
# define __STDC_TGSTRING__ 201610L

/**
 ** @file
 ** @brief Type generic string interfaces
 **
 ** @copyright 2016 Jens Gustedt
 **
 ** @remark This code is distributed under a Creative Commons
 ** Attribution 4.0 International License.
 **
 ** @warning This code is provided as is, use at your own risk.
 **
 ** This header file provides type generic replacements for the C
 ** library string functions that are "const-aware" and that chose
 ** the right alternative between narrow and wide string
 ** functions.
 **
 ** Generally this interfaces (and replaces) all the C standard
 ** functions with names starting with `str`. These are
 **
 ** - `strcat`
 ** - `strchr`
 ** - `strcmp`
 ** - `strcoll`
 ** - `strcpy`
 ** - `strcspn`
 ** - `strlen`
 ** - `strncat`
 ** - `strncmp`
 ** - `strncpy`
 ** - `strntok`
 ** - `strpbrk`
 ** - `strrchr`
 ** - `strspn`
 ** - `strstr`
 ** - `strtod`
 ** - `strtof`
 ** - `strtoimax`
 ** - `strtol`
 ** - `strtold`
 ** - `strtoll`
 ** - `strtoul`
 ** - `strtoull`
 ** - `strtoumax`
 ** - `strxfrm`
 **
 ** The interfaces that are prefixed with `mem` are more difficult
 ** to match, since the types of parameters of the existing `mem`
 ** and `wmem` functions are not consistent: the `mem` functions
 ** work with `void*`, thus on @b bytes, whereas the `wmem`
 ** functions work with `wchar_t`, thus on wide characters. The
 ** first can receive any pointer argument whereas the second can
 ** only receive wide character arrays. Generally the semantics of
 ** a type generic interface that mixes bytes and wide characters
 ** would not be clear since also the interpretation of a length
 ** parameter would change.
 **
 ** Out of these functions only the functions `memchr` and
 ** `wmemchr` have the const-awareness problem, so we provide
 ** these. Because for `wmemchr` the parameter is fixed to be
 ** derived from `wchar_t`, this one is not very difficult.
 **
 ** `memchr` is a bit tricky, because the original receives a
 ** `void const*` that might come from any data pointer. We have
 ** to do some black magic to decide if the target type is
 ** `const`-qualified.
 **
 ** This uses a lot of small stub functions that usually will be
 ** inlined. If you are a C library provider that wants to
 ** integrate this, see the discussion of ::_TG_INLINE.
 **/

# if __STDC_VERSION__ &lt 201112L
#  error "tgstring.h needs a C11 conforming compiler"
# endif

# include &ltinttypes.h&gt
# include &ltstdlib.h&gt
# include &ltstdio.h&gt
# include &ltstring.h&gt
# include &ltwchar.h&gt

/* We define a bunch of inline functions that have the only
   purpose of providing conversions to the their arguments and
   then to pass them on to the corresponding standard function. We
   use the same names as the standard function and append "_const"
   to them. This use is covered by the standard since all of the
   "str" and "wcs" names are reserved, anyhow. */

/**
 ** @def _TG_INLINE
 **
 ** We would like to have all the stubs as `inline` functions. The
 ** problem is, that if we do so, and the compiler decides not to
 ** inline the function (because of command line arguments,
 ** whatever), the symbol would be missing and the program would
 ** not link.
 **
 ** The alternatives would be
 **
 ** - `static inline`, but then the functions could not be
 **   included in other `inline` functions that are themselves not
 **   `static`.
 **
 ** - `inline` and provide all stubs in the C library.
 **
 ** - compiler magic similar to the gcc attribute as shown below
 **
 ** - `register`, if this would be included in the future
 **   standard. This would be an ideal candidate.
 **
 ** If you have such specific magic, I'd be happy to integrate
 ** your two lines, here.  If you don't, you'd have to compile
 ** this file with something equivalent to
 ** @code
 ** cc -D_TG_INLINE= -x c -o tgstring.o tgstring.h
 ** @endcode
 ** to produce an object file `tgstring.o` that you add to your C
 ** library.
 **/
#ifndef _TG_INLINE
# if __STDC_REGISTER_IN_FILE_SCOPE__
#  define _TG_INLINE register
/* Otherwise, have your platform specific definition, here*/
# elif __GNUC__
#  define _TG_INLINE __attribute__((always_inline)) inline
/* Fall back to inline, if none of that worked */
# else
#  define _TG_INLINE inline
# endif
#endif

// void *memchr(void const *s, int c, size_t n);

_TG_INLINE
void const*memchr_const(void const* _s,
                        int _c, size_t _n) {
  return memchr(_s, _c, _n);
}

# undef memchr
/**
 ** Because `wchar_t` is only a `typedef`, we can't map to the
 ** wide character version. Since the original C library interface
 ** has a `void const*` parameter, all types must be valid.
 **
 ** This uses black magic to decide if the pointer target of the
 ** first argument is `const`-qualified. Namely a conditional
 ** expression is used that aggregates type information from @a _0
 ** and a `void*`. The resulting type then is a pointer to `void`
 ** with the collection of the qualifications of the two.  The
 ** alternative part of the conditional expression must not be
 ** `(void*)0`, because that would be a null pointer constant and
 ** so the resulting type would be the original type of `_0`.
 **/
# define memchr(_0, _1, _2)                     \
_Generic(1 ? (_0) : (void*)1,                   \
         void*: memchr,                         \
         void const*: memchr_const)             \
((_0), (_1), (_2))


/**
 ** @brief An internal macro to select a const conserving string
 ** function.
 **
 ** This macro simply selects the function that corresponds to the
 ** type of argument @a X. It is not meant to be used directly but
 ** to be integrated in specific macros that overload C library
 ** functions.
 **
 ** The argument @a X must correspond to an array or pointer,
 ** otherwise an error is triggered in the controlling expression.
 **
 ** If any of the 4 cases makes no sense for the type generic
 ** interface in question, that case can be switched off by
 ** passing a 0 instead of a function. A use of that case in user
 ** code then results in a compile time error.
 **
 ** @see strchr on how to integrate this into a type generic user
 ** interface
 **/
# define _TG_TO_CONST(SN, SC, WN, WC, X, ...)   \
_Generic(&(X[0]),                               \
         char*:          SN,                    \
         char const*:    SC,                    \
         wchar_t*:       WN,                    \
         wchar_t const*: WC                     \
         )((X), __VA_ARGS__)

_TG_INLINE
wchar_t const*wmemchr_const(wchar_t const _s[static 1],
                            wchar_t _c, size_t _n) {
  return wmemchr(_s, _c, _n);
}


# undef wmemchr
/**
 ** This function only makes sense if it receives a `wchar_t`
 ** argument.
 **/
# define wmemchr(...)                                   \
  _TG_TO_CONST(0,              /* char*: error   */     \
               0,              /* const char*:error */  \
               wmemchr,        /* wchar_t*       */     \
               wmemchr_const,  /* const wchar_t* */     \
               __VA_ARGS__)

// char *strchr(char const *s, int c);

_TG_INLINE
char const*strchr_const(char const *_s, int _c) {
  return strchr(_s, _c);
}

_TG_INLINE
wchar_t const*wcschr_const(wchar_t const *_s, wchar_t _c) {
  return wcschr(_s, _c);
}

# undef strchr
# define strchr(...)                                            \
  _TG_TO_CONST(strchr, strchr_const, wcschr, wcschr_const,      \
               __VA_ARGS__)

// char *strpbrk(char const *_s, char const *_t);

_TG_INLINE
char const*strpbrk_const(char const *_s, char const *_t) {
  return strpbrk(_s, _t);
}

_TG_INLINE
wchar_t const*wcspbrk_const(wchar_t const *_s, wchar_t const *_t) {
  return wcspbrk(_s, _t);
}

# undef strpbrk
# define strpbrk(...)                                           \
  _TG_TO_CONST(strpbrk, strpbrk_const, wcspbrk, wcspbrk_const,  \
               __VA_ARGS__)

// char *strrchr(char const *s, int c);

_TG_INLINE
char const* strrchr_const(char const *_s, int _c) {
  return strrchr(_s, _c);
}

_TG_INLINE
wchar_t const* wcsrchr_const(wchar_t const *_s, wchar_t _c) {
  return wcsrchr(_s, _c);
}

# undef strrchr
# define strrchr(...)                                           \
  _TG_TO_CONST(strrchr, strrchr_const, wcsrchr, wcsrchr_const,  \
               __VA_ARGS__)


// char *strstr(char const *_s, const char *_t);

_TG_INLINE
char const*strstr_const(char const *_s, char const *_t) {
  return strstr(_s, _t);
}

_TG_INLINE
wchar_t const*wcsstr_const(wchar_t const *_s, wchar_t const *_t) {
  return wcsstr(_s, _t);
}

# undef strstr
# define strstr(...)                                            \
  _TG_TO_CONST(strstr,         /* char*               */        \
               strstr_const,   /* const char*         */        \
               wcsstr,         /* wchar_t*            */        \
               wcsstr_const,   /* const wchar_t*      */        \
               __VA_ARGS__)

/**
 ** @brief An internal macro to select a string function according
 ** to the base type `char` or `wchar_t`.
 **
 ** This macro simply adds the "wcs" prefix to the name of the
 ** function, if a `wchar_t` function is to be called. Traditional
 ** `char` strings are mapped to `char`.
 **
 ** There is no default case, because these functions need a
 ** string and not some arbitrary bytes.
 **
 ** The argument @a X must correspond to an array or pointer,
 ** otherwise an error is triggered in the controlling expression.
 **
 ** No precaution is made concerning `const`. If a `const`
 ** qualified pointer type is passed in and the function that is
 ** selected does not accept such an argument, an error is
 ** diagnosed as if the corresponding function would have been
 ** used directly.
 **
 ** @see strcpy on how to integrate this into a type generic user
 ** interface
 **/
# define _TG_STR(NAME, X, ...)                  \
_Generic(&(X[0]),                               \
         char*: str ## NAME,                    \
         char const*: str ## NAME,              \
         wchar_t*: wcs ## NAME,                 \
         wchar_t const*: wcs ## NAME            \
         )((X), __VA_ARGS__)

# undef strcpy
# define strcpy(...) _TG_STR(cpy, __VA_ARGS__)
# undef strncpy
# define strncpy(...) _TG_STR(ncpy, __VA_ARGS__)
# undef strcat
# define strcat(...) _TG_STR(cat, __VA_ARGS__)
# undef strncat
# define strncat(...) _TG_STR(ncat, __VA_ARGS__)
# undef strcmp
# define strcmp(...) _TG_STR(cmp, __VA_ARGS__)
# undef strcoll
# define strcoll(...) _TG_STR(coll, __VA_ARGS__)
# undef strncmp
# define strncmp(...) _TG_STR(ncmp, __VA_ARGS__)
# undef strxfrm
# define strxfrm(...) _TG_STR(xfrm, __VA_ARGS__)
# undef strcspn
# define strcspn(...) _TG_STR(cspn, __VA_ARGS__)
# undef strspn
# define strspn(...) _TG_STR(spn, __VA_ARGS__)
# undef strntok
# define strntok(...) _TG_STR(ntok, __VA_ARGS__)
# undef strlen
# define strlen(...) _TG_STR(len, __VA_ARGS__)


/**
 ** @brief An internal Xmacro to generate const conserving string
 ** to floating point conversion function.
 **
 ** In the case of the string to number functions the original C
 ** library functions cannot be used directly, because their
 ** second argument is an unqualified pointer to pointer.
 **
 ** @param T is the target type of the conversion
 ** @param C is the base type of the string, so `char` or `wchar_t`
 ** @param NAME is the base name for the function
 **/
#define _TG_STR2F_FUNC_(T, C, NAME)                             \
_TG_INLINE                                                      \
T _TG_ ## NAME ## _c(C const* _p, C const** _e) {               \
  return NAME(_p, (C**)_e);                                     \
}                                                               \
_TG_INLINE                                                      \
T _TG_ ## NAME ## _nc(C* _p, C** _e) {                          \
  return NAME(_p, _e);                                          \
}                                                               \
typedef T _TG_ ## NAME ## _c_ftype(C const*, C const**);        \
typedef T _TG_ ## NAME ## _nc_ftype(C*, C**)

/**
 ** @brief An internal Xmacro to generate const conserving string
 ** to floating point conversion function.
 **
 ** This macro just assembles _TG_STR2F_FUNC_() for the two cases
 ** of @a C being `char` or `wchar_t`.
 **
 ** @param T is the target type of the conversion
 ** @param NAME is the base name for the function
 **/
#define _TG_STR2F_FUNC(T, NAME)                 \
  _TG_STR2F_FUNC_(T, char, str ## NAME);        \
  _TG_STR2F_FUNC_(T, wchar_t, wcs ## NAME)


/* generate the three groups of floating point conversion functions */
_TG_STR2F_FUNC(float, tof);
_TG_STR2F_FUNC(double, tod);
_TG_STR2F_FUNC(long double, told);



/**
 ** @brief An internal Xmacro to generate const conserving string
 ** to integer conversion function.
 **/
#define _TG_STR2I_FUNC_(T, C, NAME)                             \
_TG_INLINE                                                      \
T _TG_ ## NAME ## _c(C const* _p, C const** _e, int _b) {       \
  return NAME(_p, (C**)_e, _b);                                 \
}                                                               \
_TG_INLINE                                                      \
T _TG_ ## NAME ## _nc(C* _p, C** _e, int _b) {                  \
  return NAME(_p, _e, _b);                                      \
}                                                               \
typedef T _TG_ ## NAME ## _c_ftype(C const*, C const**, int);   \
typedef T _TG_ ## NAME ## _nc_ftype(C*, C**, int)


/**
 ** @brief An internal Xmacro to generate const conserving string
 ** to integer conversion function.
 **
 ** This macro just assembles _TG_STR2I_FUNC_() for the two case
 ** of `being` `char` or `wchar_t`.
 **
 ** @param T is the target type of the conversion
 ** @param NAME is the base name for the function
 **/
#define _TG_STR2I_FUNC(T, NAME)                 \
  _TG_STR2I_FUNC_(T, char, str ## NAME);        \
  _TG_STR2I_FUNC_(T, wchar_t, wcs ## NAME)


/* generate the six groups of integer conversion functions */
_TG_STR2I_FUNC(long, tol);
_TG_STR2I_FUNC(long long, toll);
_TG_STR2I_FUNC(unsigned long, toul);
_TG_STR2I_FUNC(unsigned long long, toull);
_TG_STR2I_FUNC(intmax_t, toimax);
_TG_STR2I_FUNC(uintmax_t, toumax);

/**
 ** @brief An internal macro to select a const conserving string
 ** to integer conversion function.
 **
 ** This macro simply selects the function that corresponds to
 ** the type of argument @a X. It is not meant to be used
 ** directly but to be integrated in specific macros that
 ** overload C library functions.
 **
 ** The argument @a X must correspond to an array or pointer,
 ** otherwise an error is triggered in the controlling
 ** expression.
 **
 ** There is no default case, because these functions need a
 ** string and not some arbitrary bytes.
 **
 ** @see strtol on how to integrate this into a type generic user
 ** interface
 **/
# define _TG_STR_FUNC3(NAME, X, P, B, ...)              \
_Generic(&((*P)[0]),                                    \
         char*:          _TG_str ## NAME ## _nc,        \
         char const*:    _TG_str ## NAME ## _c,         \
         wchar_t*:       _TG_wcs ## NAME ## _nc,        \
         wchar_t const*: _TG_wcs ## NAME ## _c          \
         )((X), (P), (B))

/**
 ** @brief An internal macro to select a const conserving string
 ** to floating point conversion function.
 **
 ** @see _TG_STR_FUNC3 for a complete description of the strategy
 **/
# define _TG_STR_FUNC2(NAME, X, P, ...)                 \
_Generic(&((*P)[0]),                                    \
         char*:          _TG_str ## NAME ## _nc,        \
         char const*:    _TG_str ## NAME ## _c,         \
         wchar_t*:       _TG_wcs ## NAME ## _nc,        \
         wchar_t const*: _TG_wcs ## NAME ## _c          \
         )((X), (P))

# undef strtod
# define strtod(...) _TG_STR_FUNC2(tod, __VA_ARGS__, 0, 0, 0)
# undef strtof
# define strtof(...) _TG_STR_FUNC2(tof, __VA_ARGS__, 0, 0, 0)
# undef strtold
# define strtold(...) _TG_STR_FUNC2(told, __VA_ARGS__, 0, 0, 0)
# undef strtol
# define strtol(...) _TG_STR_FUNC3(tol, __VA_ARGS__, 0, 0, 0)
# undef strtoll
# define strtoll(...) _TG_STR_FUNC3(toll, __VA_ARGS__, 0, 0, 0)
# undef strtoul
# define strtoul(...) _TG_STR_FUNC3(toul, __VA_ARGS__, 0, 0, 0)
# undef strtoull
# define strtoull(...) _TG_STR_FUNC3(toull, __VA_ARGS__, 0, 0, 0)
# undef strtoimax
# define strtoimax(...) _TG_STR_FUNC3(toimax, __VA_ARGS__, 0, 0, 0)
# undef strtoumax
# define strtoumax(...) _TG_STR_FUNC3(toumax, __VA_ARGS__, 0, 0, 0)


#endif
#ifndef TRAMPOLINE_H
#define TRAMPOLINE_H 1
#include &ltstddef.h&gt

typedef void trampoline_type(void);

/**
 ** @brief A little function needed to pretend that the address of an
 ** object has leaked that thus the initialization of that object may
 ** not be optimized out.
 **/
inline
void* trampoline_sink(void* d) {
  __asm__ ("# do nothing" : : "g" (d) );
  return d;
}

/**
 ** @brief The maximum number of trampolines defined for this
 ** particular TU.
 **
 ** If this is not big enough compile with something like
 ** "-DTRAMPOLINE_MAX_PER_TU=XXX"
 **/
#if TRAMPOLINE_MAX_PER_TU &lt= 0
# define TRAMPOLINE_MAX_PER_TU 20
#endif

/**
 ** @brief Initialize a TU
 **
 ** This code is executed by gcc magic at the beginning of the run for
 ** each TU. Don't use it directly
 **/
__attribute__((__deprecated__("Function should not be called manually.")))
void trampoline_reserve(size_t n);

#if __GNUC__
# pragma GCC diagnostic push
# pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

/**
 ** @brief Initialize this TU
 **
 ** This code is executed by gcc magic at the beginning of the run. Don't use it directly
 **/
__attribute__((__constructor__(1001), __deprecated__("Function should not be called manually.")))
static
void trampoline_init(void){
  trampoline_reserve(TRAMPOLINE_MAX_PER_TU);
}

#if __GNUC__
# pragma GCC diagnostic pop
#endif

/**
 ** @brief the usual suspect to apply a macro successively to a whole
 ** list of arguments.
 **
 ** If the list has length N, noted in hex, the macro 'BASE ## N' is
 ** called with arguments @c (NAME, ARG1, ARG3, ... , ARGN, extra
 ** args). Make sure that it only uses the ones up to @c ARGN and
 ** ignores the extra arguments.
 **/
#define TRAMPOLINE_NARG(BASE, NAME, ...)                                \
  TRAMPOLINE_NARGS(BASE, NAME, __VA_ARGS__,                             \
                  F, E, D, C, B, A, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, )

#define TRAMPOLINE_NARGS(BASE, NAME, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _A, _B, _C, _D, _E, _F, ...) \
TRAMPOLINE_NARG_ ## _F(BASE, NAME, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _A, _B, _C, _D, _E, _F, __VA_ARGS__)

#define TRAMPOLINE_NARG_1(BASE, NAME, X, ...) BASE(NAME, X)
#define TRAMPOLINE_NARG_2(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_1(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_3(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_2(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_4(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_3(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_5(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_4(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_6(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_5(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_7(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_6(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_8(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_7(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_9(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_8(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_A(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_9(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_B(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_A(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_C(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_B(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_D(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_C(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_E(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_D(BASE, NAME, __VA_ARGS__)
#define TRAMPOLINE_NARG_F(BASE, NAME, X, ...) BASE(NAME, X) TRAMPOLINE_NARG_E(BASE, NAME, __VA_ARGS__)


#define TRAMPOLINE_TYPEOF(NAME, X) __typeof__(trampoline_ ## NAME ## _struct-&gtX)*const restrict X;

extern void const* trampoline_context(void*);                           \

/**
 ** @brief Define a trampoline.
 **
 ** This should be of the form
 ** &ltcode&gt
 ** TRAMPOLINE_DEFINE(int, fun, void) ({
 **    ... your code goes here ...
 ** })
 ** &lt/code&gt
 **
 ** Here, @c int is the return type of the function, @c fun is its
 ** name and @c void is the parameter list. Please observe the use of
 ** @c ({ }) parenthesis.
 **
 ** By using ::TRAMP the body of the function can access the variables
 ** in the context that have been tagged in the declaration by means
 ** of ::TRAMPOLINE_DECLARE
 **
 ** A function defined like this is not usable by itself, it will
 ** segfault during its initialization phase. By using
 ** ::TRAMPOLINE_POINTER the function can be contextualized and thus
 ** activated, and subsequently used through that pointer.
 **/
#define TRAMPOLINE_DEFINE(RET, FUN, ...)                                \
size_t trampoline_ ## FUN ## _index(void) {                             \
extern size_t trampoline_index(_Atomic(size_t)* loc,                    \
                                 trampoline_type* f,                    \
                                 size_t size);                          \
  static _Atomic(size_t) _idx = 0;                                      \
  return                                                                \
    trampoline_index(&_idx,                                             \
                     (trampoline_type*) (FUN),                          \
                     sizeof(trampoline_ ## FUN ## _ctxt));              \
}                                                                       \
RET FUN (__VA_ARGS__) {                                                 \
 trampoline_ ## FUN ## _ctxt const trampoline_ctxt                      \
   = *(trampoline_ ## FUN ## _ctxt*)trampoline_context(0);              \
TRAMP_PART2

#define TRAMP_PART2(...) __VA_ARGS__ }

/**
 ** @brief Declare a trampoline.
 **
 ** This should be of the form
 ** &ltcode&gt
 ** TRAMPOLINE_DECLARE({
 **     int val;
 **     double vol;
 **   })
 ** (int, fun, val, vol)
 ** (void);
 ** &lt/code&gt
 **
 ** That is it receives three parenthesized list. The first is of the
 ** form @c ({ }) and contains the types and names of the environment
 ** of the trampoline that are to be propagated. The names must match
 ** exactly those of the variables.
 **
 ** The second list is of the form @c (RET, FUN, ...) where @c RET and
 ** @c FUN are the return type and name of the function,
 ** respectively. The @c ... list is a list of the names of the
 ** propagated variables as they were given previously
 **
 ** The last @c () list is just the usual parameter list of the
 ** function.
 **
 ** By using ::TRAMP the body of the function can access the variables
 ** in the context that have been tagged in the declaration by means
 ** of ::TRAMPOLINE_DECLARE
 **
 ** A function declared like that is not usable by itself, it will
 ** segfault during its initialization phase. By using
 ** ::TRAMPOLINE_POINTER the function can be contextualized and thus
 ** activated, and subsequently used through that pointer.
 **/
#define TRAMPOLINE_DECLARE extern struct TRAMP_DPART1

#define TRAMP_DPART1(...) __VA_ARGS__ TRAMP_DPART2

#define TRAMP_DPART2(RET, FUN, ...)                             \
* trampoline_ ## FUN ## _struct;                                \
typedef struct {                                                \
  /* must be first element */                                   \
  size_t _0;                                                    \
  TRAMPOLINE_NARG(TRAMPOLINE_TYPEOF, FUN, __VA_ARGS__);         \
} trampoline_ ## FUN ## _ctxt;                                  \
extern size_t trampoline_ ## FUN ## _index(void);               \
extern RET FUN

#define TRAMPOLINE_INIT(FUN, X) .X = &X,


/**
 ** @brief Contextualize a trampoline.
 **
 ** Instantiate a dynamic version of function @a FUN that has access
 ** to the context. The variables that this function wants to access
 ** through ::TRAM must be listed in the @c ... list. Only variables
 ** that have previously been declared in ::TRAMPOLINE_DECLARE can be
 ** used in the list.
 **
 ** Variables that are not in the list cannot be accessed. Trying to
 ** do so will result in a segfault.
 **/
#define TRAMPOLINE_POINTER(FUN, ...)                                    \
((__typeof__(*(FUN))*)                                                  \
 /* the sink ensures that the compound literal is really created */     \
trampoline_sink                                                         \
((trampoline_ ## FUN ## _ctxt[1])                                       \
{{                                                                      \
/* The first element must always be the index. */                       \
trampoline_ ## FUN ## _index(),                                         \
  TRAMPOLINE_NARG(TRAMPOLINE_INIT, , __VA_ARGS__)                       \
  }}                                                                    \
 ))

/**
 ** @brief Access the propagated variable @a F.
 **
 ** This is only valid inside a function that has been defined with
 ** ::TRAMPOLINE_DEFINE.
 **/
#define TRAM(F) (*(trampoline_ctxt.F))


#endif

# A file to describe dependencies for compilations used by the POSIX
# "make" utility, see http://pubs.opengroup.org/onlinepubs/9699919799/

# Ensure that we use strict POSIX make rules.
.POSIX :

# empty the list of suffixes
.SUFFIXES :
# C files, sources
.SUFFIXES : .c .h
# products, object files, make dependencies, assembler
.SUFFIXES : .o .d .s

# The choice of the compiler. Commonly available on POSIX systems are
# compilers called clang, gcc, icc or c99. Try them in this order if
# the following does not work for you.
#
# Here we used a "wrapper" for gcc that comes with the "musl" C
# library. This has the advatage to provide full support for C11
# threads that we need for the "experience" level. On some Linux
# distributions musl is available as packages 'musl', 'musl-dev',
# 'musl-tools'. Other Linux distributions such as Alpine directly ship
# with musl as their C library.
CC = /usr/local/musl/bin/musl-gcc
#CC = clang
#CC = gcc
#CC = icc
#CC = c99

# A collection of typical flags on a Linux box with gcc or clang

# First a choice of a C standard to which your code is conforming. The
# following should be the default for a recent compiler (2018). Other
# options could be -std=c11 or -std=gnu11.
STD = -std=gnu17

# Warning options. It is important that the compiler gives you all
# that he knows.
WAR = -Wall

# Optimization options. The ones here are my favorite, maximal
# optimization for the machine on which we are compiling and maximal
# separation of functions and data into different sections.
OPT = -O3 -march=native -fdata-sections -ffunction-sections

# For the gcc and friends the addition of this flag produces a make
# dependency file with suffix .d
DEP = -MD

# One source (terran.c) also needs my macro library P99. If you
# comment the following lines out, the compilation of that file will
# not work.  Adapt to the path on your system.
P99 = ../../orwl/p99-source/p99
INC = -I${P99}

CFLAGS = ${OPT} ${WAR} ${STD} ${INC} ${DEP}

# The linker flags. Here this corresponds to eliminate all of the
# collected sections that are finally not needed in the executable.
LDFLAGS = -Wl,--gc-sections
# in the link step we need our own library
LDLIBS = -L. -lmodernC
# sometime we will need the "math" library and also "real time"
LDLIBS = -lm -lrt

# C sources that produce an executable
ROURCES =					\
	basic_blocks.c				\
	basic_blocks2.c				\
	cat.c					\
	crash.c					\
	endianess.c				\
	euclid.c				\
	extern.c				\
	fibonacci2.c				\
	fibonacci3.c				\
	fibonacci4.c				\
	fibonacci5.c				\
	fibonacci6.c				\
	fibonacci.c				\
	fibonacciCache.c			\
	fibonacciRet.c				\
	generic.c				\
	getting-started.c			\
	heron.c					\
	heron-expanded.c			\
	heron_k.c				\
	lifetime.c				\
	locale.c				\
	macro_trace.c				\
	mbstrings-main.c			\
	numberline.c				\
	precision.c				\
	rationals.c				\
	shadow.c				\
	sighandler_test.c			\
	strcpy.c				\
	strtoul.c				\
	tendots.c				\
	terran.c				\
	test_circular.c				\
	timespec.c				\
	va_arg.c				\
	yday.c


# Comment this out if your platform does not support the C11 thread model
TOURCES = B9.c B9-detach.c trampoline.c

SOURCES = ${ROURCES} ${TOURCES}

# Translation units (TU) that provide functionality that can be used
# by others. These are collected into the library libmodernC.a
RSOURCES =					\
	circular.c				\
	literals.c				\
	mbstrings.c				\
	sighandler.c				\
	stats.c

# Comment this out if your platform does not support the C11 thread model
TSOURCES = esc.c life.c termin.c

LSOURCES = ${RSOURCES} ${TSOURCES}

# TU that just prove a point.
OSOURCES =					\
	anonymous_function.c			\
	atomic_or_struct.c			\
	volatile_atomic.c

# Examples of bad TU that produce diagnostics when compiled
BSOURCES =					\
	getting-started-badly.c			\
	tgstring_test.c

# The following lines use the above to create new lists of files where
# the .c suffixes are replaced.
OBJECTS = ${SOURCES:.c=.o}

LOBJECTS = ${LSOURCES:.c=.o}

BOBJECTS = ${BSOURCES:.c=.o}

OOBJECTS = ${OSOURCES:.c=.o}

BINARIES = ${SOURCES:.c=}

DEPENDS = ${SOURCES:.c=.d} ${LSOURCES:.c=.d}

# This implicit rule tells how make is supposed to produce an object
# file (.o suffix) from a C file (.c suffix). This is needed to
# produce an executable file from your program.
#
# Here the make-special variable $&lt expands and to the dependency (the
# .o object file).
.c.o :
	${CC} ${CFLAGS} -c $&lt

# This implicit rule tells how make is supposed to produce an assembly
# file (.s suffix) from a C file (.c suffix). This is only needed if
# you want to inspect what your compiler produces from your code.
.c.s :
	${CC} ${CFLAGS} -S $&lt

# This implicit rule tells make that the dependency file (.d suffix)
# itself depends on the object file. This is a bit of a lie, because
# we will produce them along (see DEP above) when normally compiling.
.d.o :

# This implicit rule tells make that the final executable file (no
# suffix) depends on the object file (.o suffix). If your platform has
# a suffix for executables, e.g .exe, you'd have to add it here. On
# POSIX systems it is common to use the same compiler command (here
# ${CC}) also for linking.
#
# The additional make-special variable $@ expands to the target name
# (the executable).
.o :
	${CC} -o $@ ${LDFLAGS} $&lt ${LDLIBS}

# This is the first explicit target, so per default make will try to
# produce it. It is only here for the dependencies to all our
# executables, so all of these will be created, if possible.  Since
# this target has no rule of its own, a file named "binaries" will
# never be produced.
binaries : ${BINARIES}

# This rule tells make that all our executable files also depend on
# the archive 'libmodernC.a'.
${BINARIES} : libmodernC.a

# That archive depends on all the "LOBJECTS"
libmodernC.a : ${LOBJECTS}
	${AR} crf $@ $^

# This target needs some special command line arguments so it has its
# own production line.
tgstring.o : tgstring.h
	${CC} -D_TG_INLINE= -c -x c ${CFLAGS} -o tgstring.o tgstring.h

# An alternative target that just has all sources compiled.
objects : ${OBJECTS} ${LOBJECTS} ${OOBJECTS}

# Compilation of the "bad" objects will produce a lot of
# diagnostics. These are for demonstrative purposes, only.
bad : ${BOBJECTS}

# Linkage of the "bad" objects may produce executables that have
# unforseeable effects if they are run.
#
# ***** DO NOT USE THESE ****
#
# These are for demonstrative purposes, only.
verybad : ${BOBJECTS:.o=}

# They also depend on the library.
${BOBJECTS:.o=} : libmodernC.a

# Cleanup the directory from all files that we produce
clean :
	rm -f libmodernC.a ${DEPENDS} ${OBJECTS} ${LOBJECTS} ${OOBJECTS} ${BOBJECTS} ${BINARIES} ${BOBJECTS:.o=}

# Include all the produced dependency files. In POSIX, it is
# unspecified if "include" works with more than one file, but usually
# it does.
#
# The "-" in front tells make not to complain, if the dependency files
# to not exist, yet. If they are missing, make looks into its rules to
# see how to produce them, produces them and reads them.
#
# If the initial generation of make dependency files does not work for
# you, you could launch a compilation of all objects with
#
# make -i
-include ${DEPENDS}
</pre>
<div class="bookmark">./exe/speed_typer/main.html</div><pre class=html>
<kw>&lt!doctype html&gt</kw>

<kw>&lthtml lang="en"&gt</kw>
<kw>&lthead&gt</kw>
  <kw>&ltmeta charset="utf-8"&gt</kw>

  <kw>&lttitle&gt</kw>Ñ¬<kw>&lt/title&gt</kw>
<kw>&ltlink href="style.css" rel="stylesheet"/&gt</kw>
<kw>&lt/head&gt</kw>


<kw>&ltbody&gt</kw>

	<kw>&ltdiv id="container"&gt</kw>
		<kw>&ltdiv id="timer"&gt</kw>type the characters you see<kw>&lt/div&gt</kw>
		<kw>&ltdiv id="letter"&gt</kw><kw>&lt/div&gt</kw>
	<kw>&lt/div&gt</kw>
	<kw>&ltscript src="game.js"&gt</kw><kw>&lt/script&gt</kw>

<kw>&lt/body&gt</kw>
<kw>&lt/html&gt</kw>
</pre>
<div class="bookmark">./exe/speed_typer/style.css</div><pre class=css>
<sc>body {</sc>
<css>	background-color: #123;</css>
<css>	cursor: crosshair;</css>
<css>	display:flex;</css>
<css>	flex-direction : column;</css>
<css>	justify-content: center;</css>
<css>	align-items: center;</css>
<sc>}</sc>
<css></css>
<sc>div {</sc>
<css>	color: white;</css>
<css>	text-align: center;</css>
<sc>}</sc>
<css></css>
<sc>#letter {</sc>
<css>	margin-top: 5vh;</css>
<css>	padding: 20px;</css>
<css>	border: inset;</css>
<css>	border-color: #345;</css>
<css>	width: 20vw;</css>
<css>	font : 256px Georgia;</css>
<css>	vertical-align: middle;</css>
<sc>}</sc>
<css></css>
<sc>#timer {</sc>
<css>	border:  ridge;</css>
<css>	border-color: #345;</css>
<css>	padding: 5px;</css>
<css>	margin-top: 10vh;</css>
<sc>}</sc>
<css></css>
</pre>
<div class="bookmark">./exe/speed_typer/game.js</div><pre class=js>





<kw>const</kw> timer  = document.querySelector<sc>(</sc><dbl_quote>"#timer"</dbl_quote><sc>)</sc><sc>;</sc>
<kw>const</kw> letter = document.querySelector<sc>(</sc><dbl_quote>"#letter"</dbl_quote><sc>)</sc><sc>;</sc>
<kw>const</kw> chars = Array.from<sc>(</sc><dbl_quote>"<sc>!</sc>1@2#3$4%5^6&7*8<sc>(</sc>9<sc>)</sc>0_-+=QqWwEeRrTtYyUuIiOoPp<sc>{</sc><sc>[</sc><sc>}</sc><sc>]</sc>|AaSsDdFfGgHhJjKkLl<sc>:</sc><sc>;</sc>\"</dbl_quote>?&gt.&lt,MmNnBbVvCcXxZz<dbl_quote>"<sc>)</sc><sc>;</sc>

<kw>let</kw> current_letter<sc>;</sc> 
<kw>let</kw> count = 0<sc>;</sc>
<kw>let</kw> started = 0<sc>;</sc>


Array.prototype.sample = <kw>function</kw><sc>(</sc><sc>)</sc><sc>{</sc>
	<kw>return</kw> <kw>this</kw><sc>[</sc>Math.floor<sc>(</sc>Math.random<sc>(</sc><sc>)</sc>*<kw>this</kw>.length<sc>)</sc><sc>]</sc><sc>;</sc>
<sc>}</sc>

<kw>function</kw> addWordToDOM<sc>(</sc><sc>)</sc><sc>{</sc>
	current_letter = chars.sample<sc>(</sc><sc>)</sc><sc>;</sc>
	letter.innerHTML = current_letter<sc>;</sc>
<sc>}</sc>

<kw>let</kw> START_TIME<sc>;</sc>

<kw>let</kw> elapsed, cps, counter<sc>;</sc>
<kw>function</kw> updateAverage<sc>(</sc><sc>)</sc> <sc>{</sc>
	now = <kw>new</kw> Date<sc>(</sc><sc>)</sc>.getTime<sc>(</sc><sc>)</sc>/1000<sc>;</sc>
	elapsed = now - START_TIME<sc>;</sc>
	console.log<sc>(</sc>elapsed<sc>)</sc><sc>;</sc>
	cpm = Math.round<sc>(</sc>count/elapsed * 60<sc>)</sc><sc>;</sc>
	console.log<sc>(</sc>cpm<sc>)</sc><sc>;</sc>
	<kw>if</kw> <sc>(</sc>count &gt 2<sc>)</sc><sc>{</sc>
		timer.innerHTML = cpm.toString<sc>(</sc><sc>)</sc><sc>;</sc>
		timer.innerHTML = timer.innerHTML + "</dbl_quote> characters per minute<dbl_quote>"<sc>;</sc>
	<sc>}</sc>
<sc>}</sc>

document.addEventListener<sc>(</sc>"</dbl_quote>keydown<dbl_quote>", e =&gt <sc>{</sc>
	<kw>if</kw> <sc>(</sc>started == 0<sc>)</sc><sc>{</sc>
		START_TIME = <kw>new</kw> Date<sc>(</sc><sc>)</sc>.getTime<sc>(</sc><sc>)</sc>/1000<sc>;</sc>
		started = 1<sc>;</sc>
	<sc>}</sc>
	<kw>const</kw> insertedText = e.key<sc>;</sc>

	<kw>if</kw> <sc>(</sc>insertedText === current_letter<sc>)</sc> <sc>{</sc>
		addWordToDOM<sc>(</sc><sc>)</sc><sc>;</sc>
		count++<sc>;</sc>
		updateAverage<sc>(</sc><sc>)</sc><sc>;</sc>
	<sc>}</sc>
<sc>}</sc><sc>)</sc><sc>;</sc>

addWordToDOM<sc>(</sc><sc>)</sc><sc>;</sc>
</pre>
</body></html>